"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Fablo = exports.executeFabloCommand = exports.useFabloConfig = exports.useDirectory = void 0;
const child_process_1 = require("child_process");
const path = require("path");
const fs_1 = require("fs");
const fabloScriptRaw = fs_1.promises.readFile(require.resolve("../bin/fablo"));
const defaultConfigPath = require.resolve("../bin/fablo-config.json");
const defaultDirectory = path.resolve(".");
function exec(cwd, file, params) {
    return new Promise((resolve, reject) => {
        try {
            const cmd = `"${path.resolve(cwd, file)}" ${params.map((p) => `"${p}"`).join(" ")}`;
            resolve((0, child_process_1.execSync)(cmd, { stdio: "inherit", cwd }));
        }
        catch (e) {
            reject(e);
        }
    });
}
function useDirectory(directory) {
    const target = path.resolve(directory, "fablo");
    return fabloScriptRaw.then((buffer) => fs_1.promises.writeFile(target, buffer, { mode: 0o755 }));
}
exports.useDirectory = useDirectory;
function useFabloConfig(directory, config, overrideFn) {
    const targetConfigPath = path.resolve(directory, "fablo-config.json");
    if (typeof config === "string") {
        return fs_1.promises
            .readFile(path.resolve(directory, config), "utf8")
            .then((raw) => JSON.parse(raw))
            .then((obj) => useFabloConfig(directory, obj, overrideFn));
    }
    else {
        const updated = typeof overrideFn === "function" ? overrideFn(config) : config;
        return fs_1.promises.writeFile(targetConfigPath, JSON.stringify(updated, undefined, 2));
    }
}
exports.useFabloConfig = useFabloConfig;
function executeFabloCommand(directory, ...fabloCommand) {
    const dir = path.resolve(directory);
    return exec(dir, "fablo", fabloCommand);
}
exports.executeFabloCommand = executeFabloCommand;
class Fablo {
    constructor(directory) {
        this.directory = directory;
        this.inProgress = useDirectory(directory);
    }
    config(config, overrideFn) {
        this.fabloConfig = config;
        this.inProgress = this.inProgress.then(() => useFabloConfig(this.directory, config, overrideFn));
        return this;
    }
    defaultConfig(overrideFn) {
        const fullFabloConfigPath = path.resolve(this.directory, "fablo-config.json");
        // File does not exist, or if we want to override some values
        if (!(0, fs_1.existsSync)(fullFabloConfigPath) || overrideFn) {
            return this.config(defaultConfigPath, overrideFn);
        }
        // File exists and we don't want to override it
        else {
            if (!this.fabloConfig) {
                this.fabloConfig = fullFabloConfigPath;
            }
            return this;
        }
    }
    then(fn) {
        this.inProgress = this.inProgress.then(fn);
        return this;
    }
    execute(...command) {
        if (this.fabloConfig === undefined) {
            return this.defaultConfig().execute(...command);
        }
        else {
            return this.inProgress.then(() => executeFabloCommand(this.directory, ...command));
        }
    }
    static directory(directory) {
        return new Fablo(directory);
    }
    static config(config, overrideFn) {
        return Fablo.directory(defaultDirectory).config(config, overrideFn);
    }
    static defaultConfig(overrideFn) {
        return Fablo.directory(defaultDirectory).defaultConfig(overrideFn);
    }
    static then(fn) {
        return Fablo.directory(defaultDirectory).then(fn);
    }
}
exports.Fablo = Fablo;
//# sourceMappingURL=index.js.map