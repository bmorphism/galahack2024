"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetMyProfileDto = exports.GetPublicKeyDto = exports.UpdatePublicKeyDto = exports.RegisterEthUserDto = exports.RegisterUserDto = exports.GetObjectHistoryDto = exports.GetObjectDto = exports.ChainCallDTO = exports.createAndSignValidDTO = exports.createValidDTO = exports.parseValidDTO = exports.validateDTO = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const class_transformer_1 = require("class-transformer");
const class_validator_1 = require("class-validator");
const class_validator_jsonschema_1 = require("class-validator-jsonschema");
const utils_1 = require("../utils");
class DtoValidationFailedError extends utils_1.ValidationFailedError {
    constructor({ message, details }) {
        super(message, details);
    }
}
const validateDTO = async (dto) => {
    const validationErrors = await dto.validate();
    if (validationErrors.length) {
        throw new DtoValidationFailedError((0, utils_1.getValidationErrorInfo)(validationErrors));
    }
    else {
        return dto;
    }
};
exports.validateDTO = validateDTO;
/**
 * Parses JSON string and creates a Promise with valid DTO. Throws exception in case of validation errors.
 */
const parseValidDTO = async (constructor, jsonStringOrObj) => {
    const deserialized = ChainCallDTO.deserialize(constructor, jsonStringOrObj);
    await (0, exports.validateDTO)(deserialized);
    return deserialized;
};
exports.parseValidDTO = parseValidDTO;
/**
 * Creates valid DTO object from provided plain object. Throws exception in case of validation errors.
 */
const createValidDTO = async (constructor, plain) => {
    const instance = (0, class_transformer_1.plainToInstance)(constructor, plain);
    await (0, exports.validateDTO)(instance);
    return instance;
};
exports.createValidDTO = createValidDTO;
/**
 * Creates valid signed DTO object from provided plain object. Throws exception in case of validation errors.
 *
 * @deprecated Use `(await createValidDTO(...)).signed(...)` instead
 */
const createAndSignValidDTO = async (constructor, plain, privateKey) => {
    const instance = (0, class_transformer_1.plainToInstance)(constructor, plain);
    instance.sign(privateKey);
    await (0, exports.validateDTO)(instance);
    return instance;
};
exports.createAndSignValidDTO = createAndSignValidDTO;
class ChainCallDTO {
    validate() {
        return (0, class_validator_1.validate)(this);
    }
    async validateOrReject() {
        const validationErrors = await this.validate();
        if (validationErrors.length) {
            throw new DtoValidationFailedError((0, utils_1.getValidationErrorInfo)(validationErrors));
        }
    }
    serialize() {
        return (0, utils_1.serialize)(this);
    }
    static deserialize(constructor, object) {
        return (0, utils_1.deserialize)(constructor, object);
    }
    sign(privateKey, useDer = false) {
        const keyBuffer = utils_1.signatures.normalizePrivateKey(privateKey);
        this.signature = useDer
            ? utils_1.signatures.getDERSignature(this, keyBuffer)
            : utils_1.signatures.getSignature(this, keyBuffer);
    }
    /**
     * Creates a signed copy of current object.
     */
    // note: previously it was typed as "typeof this", but it's failed randomly on compilation
    signed(privateKey, useDer = false) {
        const copied = (0, class_transformer_1.instanceToInstance)(this);
        copied.sign(privateKey, useDer);
        return copied;
    }
    isSignatureValid(publicKey) {
        var _a;
        return utils_1.signatures.isValid((_a = this.signature) !== null && _a !== void 0 ? _a : "", this, publicKey);
    }
}
exports.ChainCallDTO = ChainCallDTO;
ChainCallDTO.ENCODING = "base64";
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. " +
            "The key is saved on chain and checked before execution. " +
            "If a DTO with already saved key is used in transaction, the transaction will fail with " +
            "UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. " +
            "In case of the error, no changes are saved to chain state.\n" +
            "The key is generated by the caller and should be unique for each DTO. " +
            "You can use `nanoid` library, UUID scheme, or any tool to generate unique string keys."
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsOptional)(),
    tslib_1.__metadata("design:type", String)
], ChainCallDTO.prototype, "uniqueKey", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. " +
            "The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain.\n" +
            "JSON payload to be signed is created from an object without 'signature' and 'trace` properties, " +
            "and it's keys should be sorted alphabetically and no end of line at the end. " +
            'Sample jq command to produce valid data to sign: `jq -cSj "." dto-file.json`.' +
            "Also all BigNumber data should be provided as strings (not numbers) with fixed decimal point notation.\n" +
            "The EC secp256k1 signature should be created for keccak256 hash of the data. " +
            "The recommended format of the signature is a HEX encoded string, including r + s + v values. " +
            "Signature in this format is supported by ethers.js library. " +
            "Sample signature: b7244d62671319583ea8f30c8ef3b343cf28e7b7bd56e32b21a5920752dc95b94a9d202b2919581bcf776f0637462cb67170828ddbcc1ea63505f6a211f9ac5b1b\n" +
            "This field can also contain a DER encoded signature, but this is deprecated and supported only to provide backwards compatibility. " +
            "DER encoded signature cannot be used recover user's public key from the signature, " +
            "and cannot be used with the new signature-based authorization flow for Gala Chain.\n"
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], ChainCallDTO.prototype, "signature", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Public key of the user who signed the DTO. " +
            "Required for DER encoded signatures, since they miss recovery part."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], ChainCallDTO.prototype, "signerPublicKey", void 0);
class GetObjectDto extends ChainCallDTO {
}
exports.GetObjectDto = GetObjectDto;
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], GetObjectDto.prototype, "objectId", void 0);
class GetObjectHistoryDto extends ChainCallDTO {
}
exports.GetObjectHistoryDto = GetObjectHistoryDto;
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], GetObjectHistoryDto.prototype, "objectId", void 0);
const publicKeyDescription = "A public key to be saved on chain.\n" +
    `It should be just the private part of the EC secp256k1 key, than can be retrieved this way: ` +
    "`openssl ec -in priv-key.pem -text | grep pub -A 5 | tail -n +2 | tr -d '\\n[:space:]:`. " +
    "The previous command produces an uncompressed hex string, but you can also provide an compressed one, " +
    `as well as compressed and uncompressed base64 secp256k1 key. ` +
    `A secp256k1 public key is saved on chain as compressed base64 string.`;
let RegisterUserDto = class RegisterUserDto extends ChainCallDTO {
};
exports.RegisterUserDto = RegisterUserDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: `Id of user to save public key for.`
    }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], RegisterUserDto.prototype, "user", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: publicKeyDescription }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], RegisterUserDto.prototype, "publicKey", void 0);
exports.RegisterUserDto = RegisterUserDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: `Dto for secure method to save public keys for legacy users. Method is called and signed by Curators`
    })
], RegisterUserDto);
let RegisterEthUserDto = class RegisterEthUserDto extends ChainCallDTO {
};
exports.RegisterEthUserDto = RegisterEthUserDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: publicKeyDescription }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], RegisterEthUserDto.prototype, "publicKey", void 0);
exports.RegisterEthUserDto = RegisterEthUserDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: `Dto for secure method to save public keys for Eth users. Method is called and signed by Curators`
    })
], RegisterEthUserDto);
class UpdatePublicKeyDto extends ChainCallDTO {
}
exports.UpdatePublicKeyDto = UpdatePublicKeyDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: publicKeyDescription }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], UpdatePublicKeyDto.prototype, "publicKey", void 0);
class GetPublicKeyDto extends ChainCallDTO {
}
exports.GetPublicKeyDto = GetPublicKeyDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: `Id of a public key holder. Optional field, by default caller's public key is returned.`
    }),
    (0, class_validator_1.IsOptional)(),
    tslib_1.__metadata("design:type", String)
], GetPublicKeyDto.prototype, "user", void 0);
class GetMyProfileDto extends ChainCallDTO {
}
exports.GetMyProfileDto = GetMyProfileDto;
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], GetMyProfileDto.prototype, "signature", void 0);
