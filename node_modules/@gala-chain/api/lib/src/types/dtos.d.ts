import { ValidationError } from "class-validator";
type Base<T, BaseT> = T extends BaseT ? T : never;
export type Inferred<T, BaseT = any> = T extends (infer U)[] ? Base<U, BaseT> : Base<T, BaseT>;
export interface ClassConstructor<T> {
    new (...args: unknown[]): T;
}
export declare const validateDTO: <T extends ChainCallDTO>(dto: T) => Promise<T>;
/**
 * Parses JSON string and creates a Promise with valid DTO. Throws exception in case of validation errors.
 */
export declare const parseValidDTO: <T extends ChainCallDTO>(constructor: ClassConstructor<Inferred<T, ChainCallDTO>>, jsonStringOrObj: string | Record<string, unknown>) => Promise<T>;
type NonFunctionPropertyNames<T> = {
    [K in keyof T]: T[K] extends Function ? never : K;
}[keyof T];
export type NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;
/**
 * Creates valid DTO object from provided plain object. Throws exception in case of validation errors.
 */
export declare const createValidDTO: <T extends ChainCallDTO>(constructor: ClassConstructor<T>, plain: NonFunctionProperties<T>) => Promise<T>;
/**
 * Creates valid signed DTO object from provided plain object. Throws exception in case of validation errors.
 *
 * @deprecated Use `(await createValidDTO(...)).signed(...)` instead
 */
export declare const createAndSignValidDTO: <T extends ChainCallDTO>(constructor: ClassConstructor<T>, plain: NonFunctionProperties<T>, privateKey: string) => Promise<T>;
export interface TraceContext {
    spanId: string;
    traceId: string;
}
export declare class ChainCallDTO {
    trace?: TraceContext;
    static readonly ENCODING = "base64";
    uniqueKey?: string;
    signature?: string;
    signerPublicKey?: string;
    validate(): Promise<ValidationError[]>;
    validateOrReject(): Promise<void>;
    serialize(): string;
    static deserialize<T>(constructor: ClassConstructor<Inferred<T, ChainCallDTO>>, object: string | Record<string, unknown> | Record<string, unknown>[]): T;
    sign(privateKey: string, useDer?: boolean): void;
    /**
     * Creates a signed copy of current object.
     */
    signed(privateKey: string, useDer?: boolean): this;
    isSignatureValid(publicKey: string): boolean;
}
export declare class GetObjectDto extends ChainCallDTO {
    readonly objectId: string;
}
export declare class GetObjectHistoryDto extends ChainCallDTO {
    readonly objectId: string;
}
export declare class RegisterUserDto extends ChainCallDTO {
    user: string;
    publicKey: string;
}
export declare class RegisterEthUserDto extends ChainCallDTO {
    publicKey: string;
}
export declare class UpdatePublicKeyDto extends ChainCallDTO {
    publicKey: string;
}
export declare class GetPublicKeyDto extends ChainCallDTO {
    user?: string;
}
export declare class GetMyProfileDto extends ChainCallDTO {
    signature: string;
}
export {};
