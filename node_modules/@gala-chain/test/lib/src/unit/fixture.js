"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixture = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const client_1 = require("@gala-chain/client");
const class_transformer_1 = require("class-transformer");
const logger_1 = tslib_1.__importDefault(require("fabric-shim/lib/logger"));
const TestChaincodeStub_1 = require("./TestChaincodeStub");
class Fixture {
    constructor(contractClass, writes = {}, state = {}) {
        this.writes = writes;
        this.state = state;
        this.knownUsers = {};
        const contractInstance = new contractClass();
        this.contract = new Proxy(contractInstance, {
            get: (target, prop) => {
                // check if target property is a function with ctx + dto as parameters
                if (typeof target[prop] === "function" && target[prop].length === 2) {
                    const method = target[prop];
                    return async (ctx, dto) => {
                        if (this.callingChainUser === undefined) {
                            throw new Error("ChainUser is not set.");
                        }
                        const signedDto = dto && dto.signature === undefined ? dto.signed(this.callingChainUser.privateKey) : dto;
                        await contractInstance.beforeTransaction(ctx);
                        const result = signedDto
                            ? await method.call(contractInstance, ctx, signedDto)
                            : await method.call(contractInstance, ctx);
                        await contractInstance.afterTransaction(ctx, result);
                        return result;
                    };
                }
                return target[prop];
            }
        });
        this.stub = new TestChaincodeStub_1.TestChaincodeStub([], this.state, this.writes);
        const ctxInstance = this.contract.createContext();
        ctxInstance.setChaincodeStub(this.stub);
        ctxInstance.logging = {
            setLevel: logger_1.default.setLevel,
            getLogger: (name) => {
                return logger_1.default.getLogger(name ? `${contractClass === null || contractClass === void 0 ? void 0 : contractClass.name}:${name}` : contractClass === null || contractClass === void 0 ? void 0 : contractClass.name);
            }
        };
        this.ctx = new Proxy(ctxInstance, {
            get: (target, prop) => {
                if (prop === "callingUser") {
                    return this.callingChainUser.identityKey;
                }
                return target[prop];
            }
        });
        this.callingUser("client|admin");
    }
    callingUser(user, mspId = "CuratorOrg") {
        var _a;
        if (typeof user === "string" && !user.startsWith("client|")) {
            throw new Error("Calling user string should start with 'client|', but provided: " + user);
        }
        const chainUser = typeof user === "string" ? (_a = this.knownUsers[user]) !== null && _a !== void 0 ? _a : client_1.ChainUser.withRandomKeys(user) : user;
        this.callingChainUser = chainUser;
        this.knownUsers[chainUser.identityKey] = chainUser;
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        this.ctx.setClientIdentity(this.stub.getClientIdentity(chainUser.identityKey, mspId));
        const userProfile = (0, class_transformer_1.plainToInstance)(api_1.UserProfile, {
            alias: chainUser.identityKey,
            ethAddress: chainUser.ethAddress,
            publicKey: chainUser.publicKey
        });
        const userProfileKey = this.ctx.stub.createCompositeKey("GCUP", [userProfile.ethAddress]);
        this.stub.mockState(userProfileKey, userProfile.serialize());
        const publicKey = (0, class_transformer_1.plainToInstance)(api_1.PublicKey, { publicKey: chainUser.publicKey });
        const publicKeyKey = this.ctx.stub.createCompositeKey("GCPK", [userProfile.alias]);
        this.stub.mockState(publicKeyKey, publicKey.serialize());
        return this;
    }
    savedState(...objs) {
        objs.forEach((o) => {
            try {
                this.state[o.getCompositeKey()] = o.serialize();
            }
            catch (e) {
                throw new Error(`getCompositeKey() failure for: ${o.serialize()}. Error: ${e}`);
            }
        });
        return this;
    }
    savedKVState(...objs) {
        objs.forEach(({ key, value }) => {
            this.state[key] = value;
        });
        return this;
    }
    savedRangeState(objs) {
        objs.forEach((o) => {
            this.state[o.getRangedKey()] = o.serialize();
        });
        return this;
    }
}
function fixture(contractClass) {
    return new Fixture(contractClass);
}
exports.fixture = fixture;
//# sourceMappingURL=fixture.js.map