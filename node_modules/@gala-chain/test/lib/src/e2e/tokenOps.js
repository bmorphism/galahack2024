"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchNFTInstances = exports.createTransferDto = exports.mintTokensToUsers = exports.randomize = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const globals_1 = require("@jest/globals");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const class_transformer_1 = require("class-transformer");
const nanoid_1 = require("nanoid");
const matchers_1 = require("../matchers");
function randomize(str) {
    return `${str}${(0, nanoid_1.nanoid)().replace(/[^a-z]/g, "")}`.slice(0, 30);
}
exports.randomize = randomize;
async function mintTokensToUsers(client, nftClassKey, users) {
    await createGalaNFT(client, nftClassKey);
    await grantUsersMintingAllowance(client, nftClassKey, users);
    await usersMintNFT(client, nftClassKey, users);
}
exports.mintTokensToUsers = mintTokensToUsers;
async function createTransferDto(nftClassKey, opts) {
    const tokenInstance = (0, class_transformer_1.plainToInstance)(api_1.TokenInstanceKey, {
        ...nftClassKey,
        instance: opts.tokenInstance
    });
    return (0, api_1.createValidDTO)(api_1.TransferTokenDto, {
        from: opts.from,
        to: opts.to,
        tokenInstance,
        quantity: new bignumber_js_1.default(1)
    });
}
exports.createTransferDto = createTransferDto;
async function fetchNFTInstances(client, nftClassKey, owner) {
    var _a;
    const dto = await (0, api_1.createValidDTO)(api_1.FetchBalancesDto, {
        owner,
        ...(0, class_transformer_1.instanceToPlain)(nftClassKey)
    });
    const resp = await client.evaluateTransaction("FetchBalances", dto, api_1.TokenBalance);
    (0, globals_1.expect)(resp).toEqual((0, matchers_1.transactionSuccess)([globals_1.expect.anything()]));
    return ((_a = resp.Data) !== null && _a !== void 0 ? _a : [])[0].instanceIds.sort((a, b) => a.comparedTo(b));
}
exports.fetchNFTInstances = fetchNFTInstances;
async function createGalaNFT(client, nftClassKey) {
    const galaTokenDto = await (0, api_1.createValidDTO)(api_1.CreateTokenClassDto, {
        decimals: 0,
        tokenClass: nftClassKey,
        name: nftClassKey.collection,
        symbol: nftClassKey.collection,
        description: "This is a test description!",
        isNonFungible: true,
        image: "https://app.gala.games/_nuxt/img/gala-logo_horizontal_white.8b0409c.png",
        maxSupply: new bignumber_js_1.default(10)
    });
    await client.submitTransaction("CreateTokenClass", galaTokenDto.signed(client.privateKey), api_1.TokenClassKey);
}
async function grantUsersMintingAllowance(client, nftClassKey, users) {
    const galaAllowanceDto = await (0, api_1.createValidDTO)(api_1.GrantAllowanceDto, {
        tokenInstance: (0, class_transformer_1.plainToInstance)(api_1.TokenInstanceKey, {
            ...nftClassKey,
            instance: api_1.TokenInstance.FUNGIBLE_TOKEN_INSTANCE
        }).toQueryKey(),
        allowanceType: api_1.AllowanceType.Mint,
        quantities: users.map(({ user, quantity }) => ({
            user: user.identityKey,
            quantity
        })),
        uses: new bignumber_js_1.default(10)
    });
    await client.submitTransaction("GrantAllowance", galaAllowanceDto.signed(client.privateKey), api_1.TokenAllowance);
}
async function usersMintNFT(client, nftClassKey, users) {
    for await (const { user, quantity } of users) {
        const userMintDto = await (0, api_1.createValidDTO)(api_1.MintTokenDto, {
            owner: user.identityKey,
            tokenClass: nftClassKey,
            quantity: quantity
        });
        const response = await client.submitTransaction("MintToken", userMintDto.signed(user.privateKey));
        const responseMatchers = Array.from({ length: quantity.toNumber() }).map(() => globals_1.expect.anything());
        (0, globals_1.expect)(response).toEqual((0, matchers_1.transactionSuccess)(responseMatchers));
    }
}
//# sourceMappingURL=tokenOps.js.map