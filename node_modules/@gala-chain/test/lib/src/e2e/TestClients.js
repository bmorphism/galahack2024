"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestClients = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const client_1 = require("@gala-chain/client");
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
const process_1 = tslib_1.__importDefault(require("process"));
const ContractTestClient_1 = require("./ContractTestClient");
const createChainClient_1 = require("./createChainClient");
const tokenOps_1 = require("./tokenOps");
function createChainClientsObj(user, obj) {
    const result = {};
    for (const [key, contract] of Object.entries(obj)) {
        const { name, api } = typeof contract === "string" ? { name: contract, api: client_1.commonContractAPI } : contract;
        const client = (0, createChainClient_1.createChainClient)(user, name).extendAPI(api);
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        result[key] = client;
    }
    return result;
}
function defaultChainClientsOptions() {
    return {
        assets: { name: "GalaChainToken", api: client_1.commonContractAPI },
        pk: { name: "PublicKeyContract", api: client_1.publicKeyContractAPI }
    };
}
async function create(user, opts) {
    if (user === undefined) {
        return create((0, tokenOps_1.randomize)("curator-"), opts);
    }
    if (typeof user === "string") {
        return create(client_1.ChainUser.withRandomKeys(user), opts);
    }
    if (!isUserConfig(user)) {
        return create(client_1.ChainUser.withRandomKeys(), user);
    }
    if (opts === undefined) {
        return create(user, defaultChainClientsOptions());
    }
    const clients = createChainClientsObj(user, opts);
    const disconnect = async () => {
        await Promise.all(Object.values(clients).map((c) => c.disconnect()));
    };
    return { ...clients, disconnect };
}
async function createForAdmin(opts) {
    if (opts === undefined) {
        return createForAdmin(defaultChainClientsOptions());
    }
    if (opts.pk === undefined) {
        return createForAdmin({ ...opts, pk: defaultChainClientsOptions().pk });
    }
    const admin = getAdminUser();
    const clients = (await create(admin, opts));
    const pk = clients.pk;
    return {
        ...clients,
        createRegisteredUser: async (userAlias) => createRegisteredUser(pk, userAlias)
    };
}
function isUserConfig(user) {
    return (typeof user === "object" &&
        !!user &&
        "prefix" in user &&
        "name" in user &&
        "identityKey" in user &&
        "ethAddress" in user &&
        "privateKey" in user &&
        "publicKey" in user);
}
function getAdminUser() {
    var _a;
    const privateKey = (_a = process_1.default.env.TEST_ADMIN_PRIVATE_KEY) !== null && _a !== void 0 ? _a : fs.readFileSync(path.resolve((0, ContractTestClient_1.networkRoot)(), "dev-admin-key/dev-admin.priv.hex.txt"), "utf-8").toString();
    return new client_1.ChainUser({ name: "admin", privateKey });
}
async function createRegisteredUser(client, userAlias) {
    const user = client_1.ChainUser.withRandomKeys(userAlias);
    if (userAlias === undefined) {
        const dto = await (0, api_1.createValidDTO)(api_1.RegisterEthUserDto, { publicKey: user.publicKey });
        const response = await client.RegisterEthUser(dto.signed(client.privateKey));
        if (response.Status !== api_1.GalaChainResponseType.Success) {
            throw new Error(`Failed to register eth user: ${response.Message}`);
        }
    }
    else {
        const dto = await (0, api_1.createValidDTO)(api_1.RegisterUserDto, { user: user.identityKey, publicKey: user.publicKey });
        const response = await client.RegisterUser(dto.signed(client.privateKey));
        if (response.Status !== api_1.GalaChainResponseType.Success) {
            throw new Error(`Failed to register user: ${response.Message}`);
        }
    }
    return user;
}
exports.TestClients = {
    create,
    createForAdmin
};
//# sourceMappingURL=TestClients.js.map