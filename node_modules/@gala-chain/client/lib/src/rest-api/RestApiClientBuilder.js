"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RestApiClientBuilder = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const generic_1 = require("../generic");
const FabloRestClient_1 = require("./FabloRestClient");
const GlobalRestApiConfig_1 = require("./GlobalRestApiConfig");
const RestApiClient_1 = require("./RestApiClient");
class RestApiClientBuilder extends generic_1.ChainClientBuilder {
    constructor(restApiUrl, orgMsp, credentials, restApiConfig) {
        super();
        this.restApiUrl = restApiUrl;
        this.orgMsp = orgMsp;
        this.credentials = credentials;
        this.restApiConfig = restApiConfig;
    }
    async ensureInitializedRestApi() {
        if (GlobalRestApiConfig_1.globalRestApiConfig.isHealthy(this.restApiUrl)) {
            return;
        }
        const shouldUseFabloRest = await this.shouldUseFabloRest();
        const apis = shouldUseFabloRest
            ? await this.getContractApisFromFabloRest()
            : await this.getContractApisFromGCRestApi();
        for (const api of apis) {
            GlobalRestApiConfig_1.globalRestApiConfig.setContractApi(api);
        }
        GlobalRestApiConfig_1.globalRestApiConfig.markHealthy(this.restApiUrl);
    }
    async shouldUseFabloRest() {
        var _a;
        try {
            await axios_1.default.get(`${this.restApiUrl}/user/identities`);
            return false; // won't happen for Fablo REST
        }
        catch (e) {
            // the path is present, but it should fail with 400 because of missing bearer token
            return ((_a = e.response) === null || _a === void 0 ? void 0 : _a.status) === 400;
        }
    }
    async getContractApisFromFabloRest() {
        var _a;
        const token = (_a = GlobalRestApiConfig_1.globalRestApiConfig.getAuthorizedFabloRest(this.restApiUrl)) !== null && _a !== void 0 ? _a : (await FabloRestClient_1.FabloRestClient.enroll(this.restApiUrl, this.credentials.adminKey, this.credentials.adminSecret));
        GlobalRestApiConfig_1.globalRestApiConfig.setAuthorizedFabloRest(this.restApiUrl, token);
        return await FabloRestClient_1.FabloRestClient.getContractApis(token, this.restApiUrl, this.restApiConfig);
    }
    async getContractApisFromGCRestApi() {
        return await RestApiClient_1.RestApiClient.getContractApis(this.credentials, this.restApiUrl, this.restApiConfig);
    }
    forContract(config) {
        const readyBuilder = this.ensureInitializedRestApi().then(() => this);
        return new AsyncProxyClient(readyBuilder, this.credentials.adminKey, config, this.orgMsp);
    }
}
exports.RestApiClientBuilder = RestApiClientBuilder;
class AsyncProxyClient extends generic_1.ChainClient {
    constructor(builder, adminKey, contractConfig, orgMsp) {
        super(builder, adminKey, contractConfig, orgMsp);
        this.clientPromise = builder.then((b) => {
            // Token present means we want to use Fablo REST
            const token = GlobalRestApiConfig_1.globalRestApiConfig.getAuthorizedFabloRest(b.restApiUrl);
            if (token) {
                return new FabloRestClient_1.FabloRestClient(Promise.resolve(b), b.restApiUrl, contractConfig, b.credentials, Promise.resolve(token), this.orgMsp);
            }
            else {
                return new RestApiClient_1.RestApiClient(Promise.resolve(b), b.restApiUrl, contractConfig, b.credentials, this.orgMsp);
            }
        });
    }
    async disconnect() {
        const client = await this.clientPromise;
        await client.disconnect();
    }
    forUser(userId, secret) {
        this.clientPromise = this.clientPromise.then((c) => c.forUser(userId, secret));
        return this;
    }
    async evaluateTransaction(method, dtoOrResp, resp) {
        const client = await this.clientPromise;
        // @ts-expect-error - method overload signatures fail for some reason on dtoOrResp
        return await client.evaluateTransaction(method, dtoOrResp, resp);
    }
    async submitTransaction(method, dtoOrResp, resp) {
        const client = await this.clientPromise;
        // @ts-expect-error - method overload signatures fail for some reason on dtoOrResp
        return await client.submitTransaction(method, dtoOrResp, resp);
    }
}
