"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FabloRestClient = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const axios_1 = tslib_1.__importDefault(require("axios"));
const generic_1 = require("../generic");
const GlobalRestApiConfig_1 = require("./GlobalRestApiConfig");
const catchAxiosError_1 = require("./catchAxiosError");
async function getPath(restApiUrl, cfg, method, isWrite) {
    const { api, contractPath } = GlobalRestApiConfig_1.globalRestApiConfig.getContractApi(cfg);
    const methodApi = api.methods.find((m) => m.methodName === method);
    if (!methodApi) {
        throw new Error(`Cannot find method API for method ${method} and contract ${contractPath}`);
    }
    if (isWrite && !methodApi.isWrite) {
        throw new Error(`Method ${method} is read-only`);
    }
    if (!isWrite && methodApi.isWrite) {
        throw new Error(`Method ${method} is not read-only`);
    }
    const type = isWrite ? "invoke" : "query";
    return `${restApiUrl}/${type}/${cfg.channelName}/${cfg.chaincodeName}`;
}
class FabloRestClient extends generic_1.ChainClient {
    constructor(builder, restApiUrl, contractConfig, credentials, token, orgMsp) {
        super(builder, credentials.adminKey, contractConfig, orgMsp);
        this.credentials = credentials;
        this.token = token;
        this.restApiUrl = builder.then(() => restApiUrl);
    }
    async isReady() {
        await this.builder;
        await this.token;
        return true;
    }
    async disconnect() {
        // ensure all promises end, then do nothing
        await this.isReady();
    }
    async submitTransaction(method, dtoOrResp, resp) {
        const path = await getPath(await this.restApiUrl, this.contractConfig, method, true);
        return this.post(path, method, dtoOrResp, resp);
    }
    async evaluateTransaction(method, dtoOrResp, resp) {
        const path = await getPath(await this.restApiUrl, this.contractConfig, method, false);
        return this.post(path, method, dtoOrResp, resp);
    }
    async post(path, methodName, dtoOrResp, resp) {
        var _a, _b, _c;
        const [dto, responseType] = (0, generic_1.isClassType)(dtoOrResp) ? [undefined, dtoOrResp] : [dtoOrResp, resp];
        const serialized = (_a = dto === null || dto === void 0 ? void 0 : dto.serialize()) !== null && _a !== void 0 ? _a : "{}";
        const payload = { method: `${this.contractConfig.contractName}:${methodName}`, args: [serialized] };
        const headers = {
            Authorization: `Bearer ${await this.token}`
        };
        const response = await axios_1.default.post(path, payload, { headers }).catch((e) => (0, catchAxiosError_1.catchAxiosError)(e));
        console.log(`${payload.method} response: `, JSON.stringify(response.data.response));
        return api_1.GalaChainResponse.deserialize(responseType, (_c = (_b = response === null || response === void 0 ? void 0 : response.data) === null || _b === void 0 ? void 0 : _b.response) !== null && _c !== void 0 ? _c : {});
    }
    static async enroll(restApiUrl, userId, secret) {
        const response = await axios_1.default
            .post(`${restApiUrl}/user/enroll`, { id: userId, secret })
            .catch((e) => (0, catchAxiosError_1.catchAxiosError)(e));
        if (!response.data.token) {
            throw new Error(`User enrollment failed, invalid response: ${JSON.stringify(response.data)}`);
        }
        return response.data.token;
    }
    forUser(userId, secret) {
        this.token = this.restApiUrl.then((url) => FabloRestClient.enroll(url, userId, secret !== null && secret !== void 0 ? secret : this.credentials.adminSecret));
        return this;
    }
    static async getContractApis(token, restApiUrl, restApiConfig) {
        const headers = {
            Authorization: `Bearer ${token}`
        };
        const contractApis = [];
        for (const channel of restApiConfig.channels) {
            for (const contract of channel.contracts) {
                const contractPath = `${channel.channelName}/${contract.chaincodeName}`;
                const getApiPath = `${restApiUrl}/query/${contractPath}`;
                const payload = { method: `${contract.contractName}:GetContractAPI`, args: [] };
                console.log(`Getting contract API for ${contractPath}, payload: ${JSON.stringify(payload)}`);
                const apiResponse = await axios_1.default
                    .post(getApiPath, payload, { headers })
                    .catch((e) => (0, catchAxiosError_1.catchAxiosError)(e));
                console.log(`Got contract API for ${contractPath}: `, JSON.stringify(apiResponse.data));
                if (!api_1.GalaChainResponse.isSuccess(apiResponse.data.response)) {
                    throw new Error(`Failed to get ${payload.method} for ${contractPath}: ${JSON.stringify(apiResponse.data)}`);
                }
                contractApis.push({
                    channelName: channel.channelName,
                    chaincodeName: contract.chaincodeName,
                    contractName: contract.contractName,
                    contractPath: contractPath,
                    api: apiResponse.data.response.Data
                });
            }
        }
        return contractApis;
    }
}
exports.FabloRestClient = FabloRestClient;
