"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CAClient = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fabric_ca_client_1 = tslib_1.__importDefault(require("fabric-ca-client"));
const fabric_network_1 = require("fabric-network");
class CAClient {
    constructor(orgMsp, adminId, adminSecret, connectionProfile) {
        this.orgMsp = orgMsp;
        this.caHostName = getCAHostName(connectionProfile, orgMsp);
        this.caClient = buildCAClient(connectionProfile, this.caHostName);
        this.wallet = getGlobalWallet(this.orgMsp);
        this.adminId = adminId;
        this.enrolledAdmin = this.wallet.then(async (wallet) => {
            const identity = await enrollUser(this.caClient, wallet, orgMsp, adminId, adminSecret);
            if (identity === undefined) {
                throw new Error(`Failed to enroll admin user (${adminId})`);
            }
            else {
                return identity;
            }
        });
    }
    async isReady() {
        await this.enrolledAdmin;
        return true;
    }
    async getIdentityOrRegisterUser(userId) {
        await this.isReady();
        const identity = await this.wallet.then((w) => w.get(userId));
        if (identity !== undefined) {
            return identity;
        }
        // register
        const userSecret = await registerUser(this.caClient, this.adminId, await this.wallet, userId, this.affiliation);
        // enroll
        return await enrollUser(this.caClient, await this.wallet, this.orgMsp, userId, userSecret);
    }
}
exports.CAClient = CAClient;
function getCAHostName(connectionProfile, orgMsp) {
    var _a, _b, _c;
    const caHostName = (_c = (_b = (_a = connectionProfile === null || connectionProfile === void 0 ? void 0 : connectionProfile.organizations) === null || _a === void 0 ? void 0 : _a[orgMsp]) === null || _b === void 0 ? void 0 : _b.certificateAuthorities) === null || _c === void 0 ? void 0 : _c[0];
    if (caHostName === undefined) {
        const msg = `CA host name not found in connection profile file at .organizations.${orgMsp}.certificateAuthorities[0]`;
        throw new Error(msg);
    }
    return caHostName;
}
function buildCAClient(ccp, caHostName) {
    var _a, _b;
    const caInfo = (_a = ccp.certificateAuthorities) === null || _a === void 0 ? void 0 : _a[caHostName];
    if (caInfo === undefined) {
        const msg = `CA config not found in connection profile file at .certificateAuthorities.${caHostName}`;
        throw new Error(msg);
    }
    const caUrl = caInfo.url;
    if (caUrl === undefined) {
        const msg = `CA url not found in connection profile file at .certificateAuthorities.${caHostName}.url`;
        throw new Error(msg);
    }
    const tlsCACerts = caInfo.tlsCACerts;
    const caTLSCACerts = (_b = tlsCACerts === null || tlsCACerts === void 0 ? void 0 : tlsCACerts.pem) !== null && _b !== void 0 ? _b : tlsCACerts === null || tlsCACerts === void 0 ? void 0 : tlsCACerts.path;
    const tlsConfig = caTLSCACerts ? { trustedRoots: [caTLSCACerts], verify: false } : undefined;
    const caName = caInfo.caName;
    if (caName === undefined) {
        const msg = `CA name not found in connection profile file at .certificateAuthorities.${caHostName}.caName`;
        throw new Error(msg);
    }
    return new fabric_ca_client_1.default(caUrl, tlsConfig, caName);
}
async function enrollUser(caClient, wallet, orgMspId, userId, userSecret) {
    // Check to see if we've already enrolled the admin user.
    const identity = await wallet.get(userId);
    if (identity !== undefined) {
        return identity;
    }
    // Enroll the user, and import the new identity into the wallet.
    const enrollment = await caClient.enroll({
        enrollmentID: userId,
        enrollmentSecret: userSecret
    });
    const x509Identity = {
        credentials: {
            certificate: enrollment.certificate,
            privateKey: enrollment.key.toBytes()
        },
        mspId: orgMspId,
        type: "X.509"
    };
    await wallet.put(userId, x509Identity);
    return x509Identity;
}
async function registerUser(caClient, adminId, wallet, userId, affiliation) {
    const adminIdentity = await wallet.get(adminId);
    if (!adminIdentity) {
        throw new Error("An identity for the admin user does not exist in the wallet");
    }
    // build a user object for authenticating with the CA
    const provider = wallet.getProviderRegistry().getProvider(adminIdentity.type);
    const adminUser = await provider.getUserContext(adminIdentity, adminId);
    return await caClient.register({
        affiliation: affiliation,
        enrollmentID: userId,
        role: "client",
        maxEnrollments: 0
    }, adminUser);
}
const globalWallets = {};
function getGlobalWallet(orgMsp) {
    if (globalWallets[orgMsp] === undefined) {
        globalWallets[orgMsp] = fabric_network_1.Wallets.newInMemoryWallet();
    }
    return globalWallets[orgMsp];
}
