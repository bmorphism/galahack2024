"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lockTokens = exports.lockToken = void 0;
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const allowances_1 = require("../allowances");
const balances_1 = require("../balances");
const token_1 = require("../token");
const utils_1 = require("../utils");
const LockError_1 = require("./LockError");
async function lockToken(ctx, { owner: optionalOwner, lockAuthority, tokenInstanceKey, quantity, allowancesToUse, name, expires, verifyAuthorizedOnBehalf }) {
    var _a;
    const msg = `LockToken ${tokenInstanceKey.toStringKey()} of ${optionalOwner !== null && optionalOwner !== void 0 ? optionalOwner : "?"}, ` +
        `lockAuthority: ${lockAuthority}, allowancesToUse: ${allowancesToUse.length}`;
    ctx.logger.info(msg);
    if (!tokenInstanceKey.isFungible() && !quantity.isEqualTo(1)) {
        throw new LockError_1.NftInvalidQuantityLockError(quantity, tokenInstanceKey.toStringKey());
    }
    if (expires > 0 && expires < ctx.txUnixTime) {
        throw new LockError_1.InvalidExpirationError(expires);
    }
    // Get the token instance
    const tokenInstance = await (0, token_1.fetchTokenInstance)(ctx, tokenInstanceKey);
    // Determine if user acts as a bridge
    const authorizedOnBehalf = await verifyAuthorizedOnBehalf(tokenInstanceKey.getTokenClassKey());
    const callingOnBehalf = (_a = authorizedOnBehalf === null || authorizedOnBehalf === void 0 ? void 0 : authorizedOnBehalf.callingOnBehalf) !== null && _a !== void 0 ? _a : ctx.callingUser;
    // Determine actual owner of the token
    const owner = optionalOwner !== null && optionalOwner !== void 0 ? optionalOwner : callingOnBehalf;
    // If a user is trying to lock tokens on someone else's behalf, we need to verify and use allowances
    if (owner !== callingOnBehalf) {
        const msg = `LockToken executed on behalf of another user (fromPerson: ${owner}, callingUser: ${callingOnBehalf})`;
        ctx.logger.info(msg);
        // for initial support of fungible tokens, require owner to be the caller.
        if (tokenInstanceKey.isFungible()) {
            throw new api_1.NotImplementedError("LockToken is not supported for fungible tokens", {
                instanceKey: tokenInstanceKey.toStringKey()
            });
        }
        await (0, allowances_1.verifyAndUseAllowances)(ctx, owner, tokenInstanceKey, quantity, tokenInstance, callingOnBehalf, api_1.AllowanceType.Lock, allowancesToUse);
    }
    // Do the locking
    const balance = await (0, balances_1.fetchOrCreateBalance)(ctx, owner, tokenInstanceKey);
    const hold = await api_1.TokenHold.createValid({
        createdBy: callingOnBehalf,
        instanceId: tokenInstance.instance,
        quantity: quantity,
        created: ctx.txUnixTime,
        expires: expires,
        name: name,
        lockAuthority
    });
    if (tokenInstanceKey.isFungible()) {
        balance.ensureCanLockQuantity(hold).lock();
    }
    else {
        balance.ensureCanLockInstance(hold, ctx.txUnixTime).lock();
    }
    await (0, utils_1.putChainObject)(ctx, balance);
    return balance;
}
exports.lockToken = lockToken;
async function lockTokens(ctx, { tokenInstances, allowancesToUse, name, lockAuthority, expires, verifyAuthorizedOnBehalf }) {
    const responses = [];
    for (const { quantity, tokenInstanceKey, owner } of tokenInstances) {
        const updatedBalance = await lockToken(ctx, {
            owner,
            lockAuthority,
            tokenInstanceKey,
            quantity,
            allowancesToUse,
            name,
            expires,
            verifyAuthorizedOnBehalf: verifyAuthorizedOnBehalf
        });
        responses.push(updatedBalance);
    }
    return responses;
}
exports.lockTokens = lockTokens;
