"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unlockTokens = exports.unlockFungibleToken = exports.unlockToken = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const balances_1 = require("../balances");
const token_1 = require("../token");
const fetchTokenClasses_1 = require("../token/fetchTokenClasses");
const utils_1 = require("../utils");
const LockError_1 = require("./LockError");
async function unlockToken(ctx, { tokenInstanceKey, name, quantity }) {
    if (tokenInstanceKey.isFungible()) {
        return unlockFungibleToken(ctx, { tokenInstanceKey, name, quantity });
    }
    // owner is always present for NFT instances
    const tokenInstance = await (0, token_1.fetchTokenInstance)(ctx, tokenInstanceKey);
    const owner = tokenInstance.owner;
    const balance = await (0, balances_1.fetchOrCreateBalance)(ctx, owner, tokenInstanceKey.getTokenClassKey());
    const applicableHold = balance.findLockedHold(tokenInstanceKey.instance, name, ctx.txUnixTime);
    // determine if user is authorized to unlock
    let authorized = false;
    if ((applicableHold === null || applicableHold === void 0 ? void 0 : applicableHold.lockAuthority) !== undefined) {
        // there is lock authority, so only lock authority can unlock
        authorized = applicableHold.lockAuthority === ctx.callingUser;
    }
    else {
        // there is no lock authority, so only lock creator or balance owner can unlock
        authorized = (applicableHold === null || applicableHold === void 0 ? void 0 : applicableHold.createdBy) === ctx.callingUser || balance.owner === ctx.callingUser;
    }
    // if calling user is not authorized, always token class authority can unlock
    if (!authorized) {
        const tokenClass = await (0, fetchTokenClasses_1.fetchTokenClass)(ctx, tokenInstanceKey);
        const isTokenAuthority = tokenClass.authorities.includes(ctx.callingUser);
        if (!isTokenAuthority) {
            throw new LockError_1.UnlockForbiddenUserError(ctx.callingUser, tokenInstanceKey.toStringKey());
        }
    }
    if (applicableHold === undefined) {
        // we assume lock may have expired or been unlocked already
        return balance;
    }
    balance.ensureCanUnlockInstance(applicableHold.instanceId, name, ctx.txUnixTime).unlock();
    await (0, utils_1.putChainObject)(ctx, balance);
    return balance;
}
exports.unlockToken = unlockToken;
async function unlockFungibleToken(ctx, { tokenInstanceKey, name, quantity }) {
    const owner = ctx.callingUser;
    const quantityToUnlock = quantity !== null && quantity !== void 0 ? quantity : new bignumber_js_1.default("0");
    if (quantityToUnlock.isEqualTo("0")) {
        throw new api_1.ValidationFailedError(`Quantity not provided for Unlock Fungible Token Request.`);
    }
    const balance = await (0, balances_1.fetchOrCreateBalance)(ctx, owner, tokenInstanceKey.getTokenClassKey());
    // determine if user is authorized to unlock
    const tokenClass = await (0, fetchTokenClasses_1.fetchTokenClass)(ctx, tokenInstanceKey);
    const isTokenAuthority = tokenClass.authorities.includes(ctx.callingUser);
    if (!isTokenAuthority && ctx.callingUser !== owner) {
        throw new LockError_1.UnlockForbiddenUserError(ctx.callingUser, tokenInstanceKey.toStringKey());
    }
    balance.ensureCanUnlockQuantity(quantityToUnlock, ctx.txUnixTime, name, ctx.callingUser).unlock();
    await (0, utils_1.putChainObject)(ctx, balance);
    return balance;
}
exports.unlockFungibleToken = unlockFungibleToken;
async function unlockTokens(ctx, params) {
    const balances = [];
    for (const p of params) {
        const balance = await unlockToken(ctx, p);
        balances.push(balance);
    }
    return balances;
}
exports.unlockTokens = unlockTokens;
