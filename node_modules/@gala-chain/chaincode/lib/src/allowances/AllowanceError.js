"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AllowanceUsersMismatchError = exports.GrantAllowanceFailedError = exports.InsufficientAllowanceError = exports.UnauthorizedAllowanceRefreshError = exports.TotalSupplyExceededError = exports.MintCapacityExceededError = exports.InvalidMintError = exports.DuplicateAllowanceError = exports.InsufficientTokenBalanceError = exports.InvalidTokenOwnerError = exports.DuplicateUserError = exports.BalanceNotFoundError = void 0;
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
class BalanceNotFoundError extends api_1.NotFoundError {
    constructor(user) {
        super(`No balance found for user id ${user}`, { user });
    }
}
exports.BalanceNotFoundError = BalanceNotFoundError;
class DuplicateUserError extends api_1.ValidationFailedError {
    constructor(users) {
        super(`dto.quantities must contain a unique set of users. Users cannot be duplicated in a single GrantAllowance call: ${users.join(", ")}`, { users });
    }
}
exports.DuplicateUserError = DuplicateUserError;
class InvalidTokenOwnerError extends api_1.ValidationFailedError {
    constructor(callingUser, tokenInstanceKey, allowanceType, owner) {
        super(`User ${callingUser} does not own the token ${tokenInstanceKey} owned by ${owner} and so cannot grant a ${allowanceType} allowance.`, { callingUser, tokenInstanceKey, allowanceType, owner });
    }
}
exports.InvalidTokenOwnerError = InvalidTokenOwnerError;
class InsufficientTokenBalanceError extends api_1.ValidationFailedError {
    constructor(callingUser, tokenInstanceKey, allowanceType, userBalance, allowanceQuantity, lockedQuantity) {
        super(`User ${callingUser} has insufficient total balance ${userBalance} minus locked balance ${lockedQuantity} for token ` +
            `${tokenInstanceKey} to grant ${allowanceType} allowance for quantity: ${allowanceQuantity}.`, { callingUser, tokenInstanceKey, allowanceType, userBalance, allowanceQuantity });
    }
}
exports.InsufficientTokenBalanceError = InsufficientTokenBalanceError;
class DuplicateAllowanceError extends api_1.ConflictError {
    constructor(allowanceKey, payload) {
        const msg = `An unused allowance exists for the provided key: ${allowanceKey}. ` +
            `Use the existing allowance, or update its properties (if necessary) with ${`RefreshAllowances`}`;
        super(msg, payload);
    }
}
exports.DuplicateAllowanceError = DuplicateAllowanceError;
class InvalidMintError extends api_1.ValidationFailedError {
    constructor(msg) {
        super(msg);
    }
}
exports.InvalidMintError = InvalidMintError;
class MintCapacityExceededError extends api_1.ValidationFailedError {
    constructor(tokenClassKey, maxCapacity, quantity) {
        super(`Mint would exceed token maxCapacity ${tokenClassKey}. Max capacity: ${maxCapacity.toFixed()}. Mint quantity: ${quantity.toFixed()}.`, { tokenClassKey, maxCapacity, quantity });
    }
}
exports.MintCapacityExceededError = MintCapacityExceededError;
class TotalSupplyExceededError extends api_1.ValidationFailedError {
    constructor(tokenClassKey, maxSupply, quantity) {
        super(`Mint would exceed token maxSupply ${tokenClassKey}. Max Supply: ${maxSupply.toFixed()}. Mint quantity: ${quantity.toFixed()}.`, { tokenClassKey, maxSupply, quantity });
    }
}
exports.TotalSupplyExceededError = TotalSupplyExceededError;
class UnauthorizedAllowanceRefreshError extends api_1.ForbiddenError {
    constructor(user, grantedBy) {
        super(`User ${user} attempted to refresh an allowance granted by another user: ${grantedBy}`, {
            user,
            grantedBy
        });
    }
}
exports.UnauthorizedAllowanceRefreshError = UnauthorizedAllowanceRefreshError;
class InsufficientAllowanceError extends api_1.ValidationFailedError {
    constructor(user, allowedQuantity, allowanceType, quantity, tokenInstanceKey, grantedBy) {
        const action = api_1.AllowanceType[allowanceType];
        const message = `${user} does not have sufficient allowances (${allowedQuantity.toFixed()}) to ${action} ${quantity.toFixed()} of token ${tokenInstanceKey}, grantedBy: ${grantedBy}`;
        super(message, {
            user,
            allowedQuantity: allowedQuantity.toFixed(),
            quantity: quantity.toFixed(),
            tokenInstanceKey: tokenInstanceKey.toStringKey(),
            grantedBy
        });
    }
}
exports.InsufficientAllowanceError = InsufficientAllowanceError;
class GrantAllowanceFailedError extends api_1.DefaultError {
    constructor(errors) {
        super(`GrantAllowanceByPartialKey failed for ${errors.length} allowances: ${errors
            .map((e) => e.message)
            .join("; ")}`, { errorPayloads: errors.map((e) => e.payload) });
    }
}
exports.GrantAllowanceFailedError = GrantAllowanceFailedError;
class AllowanceUsersMismatchError extends api_1.ValidationFailedError {
    constructor(allowance, expectedGrantedBy, expectedGrantedTo) {
        const allowanceKey = allowance.getCompositeKey();
        const message = `Allowance users mismatch. Allowance ${allowanceKey} was granted by ${allowance.grantedBy} (expected: ${expectedGrantedBy}), and granted to ${allowance.grantedTo} (expected: ${expectedGrantedTo})`;
        super(message, {
            allowanceKey,
            grantedBy: allowance.grantedBy,
            grantedTo: allowance.grantedTo,
            expectedGrantedBy,
            expectedGrantedTo
        });
    }
}
exports.AllowanceUsersMismatchError = AllowanceUsersMismatchError;
