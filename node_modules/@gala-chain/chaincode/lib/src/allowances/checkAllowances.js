"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkAllowances = exports.cleanAllowances = void 0;
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const bignumber_js_1 = require("bignumber.js");
const balances_1 = require("../balances");
const deleteAllowances_1 = require("./deleteAllowances");
function isAllowanceSpent(allowance) {
    return (allowance.usesSpent.isGreaterThanOrEqualTo(allowance.uses) ||
        allowance.quantitySpent.isGreaterThanOrEqualTo(allowance.quantity));
}
function isAllowanceExpired(ctx, allowance) {
    return allowance.expires !== 0 && allowance.expires !== undefined && allowance.expires <= ctx.txUnixTime;
}
async function doesGrantorHaveToken(ctx, allowance) {
    // This check is only for non-mint allowance types
    if (allowance.allowanceType === api_1.AllowanceType.Mint)
        return true;
    const balancesData = {
        owner: allowance.grantedBy,
        collection: allowance.collection,
        category: allowance.category,
        type: allowance.type,
        additionalKey: allowance.additionalKey
    };
    const balances = await (0, balances_1.fetchBalances)(ctx, balancesData);
    return balances.length > 0;
}
async function isAllowanceInvalid(ctx, allowance) {
    return (isAllowanceSpent(allowance) ||
        isAllowanceExpired(ctx, allowance) ||
        !(await doesGrantorHaveToken(ctx, allowance)));
}
async function cleanAllowances(ctx, allowancesToClean, authorizedOnBehalf) {
    const deleteActions = [];
    for (let i = allowancesToClean.length - 1; i >= 0; i--) {
        const allowance = allowancesToClean[i];
        const isInvalid = await isAllowanceInvalid(ctx, allowance);
        if (isInvalid) {
            const deleteAllowanceParams = {
                grantedTo: allowance.grantedTo,
                grantedBy: allowance.grantedBy,
                collection: allowance.collection,
                category: allowance.category,
                type: allowance.type,
                additionalKey: allowance.additionalKey,
                instance: allowance.instance.toString(),
                allowanceType: allowance.allowanceType,
                created: allowance.created
            };
            deleteActions.push((0, deleteAllowances_1.deleteOneAllowance)(ctx, deleteAllowanceParams, authorizedOnBehalf));
            deleteActions.push(ctx.stub.deleteState(allowance.getCompositeKey()));
            allowancesToClean.splice(i, 1);
        }
    }
    await Promise.all(deleteActions);
    return allowancesToClean;
}
exports.cleanAllowances = cleanAllowances;
// Check if a user has enough allowance to do a certain thing
async function checkAllowances(ctx, applicableAllowances, tokenInstanceKey, action, callingOnBehalf) {
    // Sum the quantity applicable
    let totalAllowance = new bignumber_js_1.BigNumber(0);
    const validAllowances = await cleanAllowances(ctx, applicableAllowances, callingOnBehalf);
    validAllowances.forEach((allowance) => {
        // Check if the token instance matches
        // Check if the action matches
        // Check if the swap has expired
        if (allowance.collection === tokenInstanceKey.collection &&
            allowance.category === tokenInstanceKey.category &&
            allowance.type === tokenInstanceKey.type &&
            allowance.additionalKey === tokenInstanceKey.additionalKey &&
            allowance.instance.isEqualTo(tokenInstanceKey.instance) &&
            allowance.allowanceType === action &&
            (allowance.expires === 0 || (allowance.expires && allowance.expires >= ctx.txUnixTime))) {
            totalAllowance = totalAllowance.plus(allowance.quantity).minus(allowance.quantitySpent);
        }
    });
    // return a comparison of total allowance and the requested quantity
    return totalAllowance;
}
exports.checkAllowances = checkAllowances;
