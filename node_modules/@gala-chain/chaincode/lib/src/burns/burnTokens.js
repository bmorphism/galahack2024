"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.burnTokens = void 0;
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const bignumber_js_1 = require("bignumber.js");
const allowances_1 = require("../allowances");
const balances_1 = require("../balances");
const token_1 = require("../token");
const types_1 = require("../types");
const utils_1 = require("../utils");
const BurnError_1 = require("./BurnError");
const fetchBurns_1 = require("./fetchBurns");
async function createTokenBurn(ctx, burnedBy, { collection, category, type, additionalKey, instance }, quantity) {
    return await (0, types_1.createValidChainObject)(api_1.TokenBurn, {
        burnedBy,
        collection,
        category,
        type,
        additionalKey,
        instance,
        created: ctx.txUnixTime,
        quantity
    });
}
async function createTokenBurnCounter(ctx, tokenBurn) {
    const { collection, category, type, additionalKey, instance, burnedBy, created, quantity } = tokenBurn;
    const referenceId = api_1.ChainObject.getStringKeyFromParts([
        burnedBy,
        collection,
        category,
        type,
        additionalKey,
        burnedBy,
        `${created}`
    ]);
    const timeKey = (0, utils_1.inverseTime)(ctx, 0);
    const epoch = (0, utils_1.inverseEpoch)(ctx, 0);
    const totalKnownBurnsCount = await (0, fetchBurns_1.fetchKnownBurnCount)(ctx, {
        collection,
        category,
        type,
        additionalKey
    });
    const burnCounter = await (0, types_1.createValidChainObject)(api_1.TokenBurnCounter, {
        collection,
        category,
        type,
        additionalKey,
        timeKey,
        burnedBy,
        instance,
        totalKnownBurnsCount,
        created,
        quantity,
        referenceId,
        epoch
    });
    return burnCounter;
}
async function burnTokens(ctx, { owner, toBurn, 
// NOTE: flag used so burnAndMint and bridgeTokenOut can bypass allowance check.
// This suggests we might want to refactor burnAndMint, but this was outside the scope of burn allowances
preValidated }) {
    var _a;
    const burnResponses = [];
    for (const tokenQuantity of toBurn) {
        const tokenInstance = await (0, token_1.fetchTokenInstance)(ctx, tokenQuantity.tokenInstanceKey);
        const tokenInstanceClassKey = await api_1.TokenClass.buildClassKeyObject(tokenInstance);
        const tokenClass = await (0, utils_1.getObjectByKey)(ctx, api_1.TokenClass, api_1.TokenClass.getCompositeKeyFromParts(api_1.TokenClass.INDEX_KEY, api_1.TokenClass.buildClassKeyList(tokenInstanceClassKey)));
        let applicableAllowanceResponse = [];
        // if user is not the owner, check allowances:
        if (ctx.callingUser !== owner && !preValidated) {
            // Get allowances
            const fetchAllowancesData = {
                grantedTo: ctx.callingUser,
                collection: tokenInstanceClassKey.collection,
                category: tokenInstanceClassKey.category,
                type: tokenInstanceClassKey.type,
                additionalKey: tokenInstanceClassKey.additionalKey
            };
            applicableAllowanceResponse = await (0, allowances_1.fetchAllowances)(ctx, fetchAllowancesData);
            // Check allowances
            const totalAllowance = await (0, allowances_1.checkAllowances)(ctx, applicableAllowanceResponse, tokenQuantity.tokenInstanceKey, api_1.AllowanceType.Burn, ctx.callingUser);
            if (totalAllowance.isLessThan(tokenQuantity.quantity)) {
                throw new BurnError_1.InsufficientBurnAllowanceError(ctx.callingUser, totalAllowance, tokenQuantity.quantity, tokenQuantity.tokenInstanceKey, owner);
            }
            // if possible, spend allowances
            const allowancesUsed = await (0, allowances_1.useAllowances)(ctx, new bignumber_js_1.BigNumber(tokenQuantity.quantity), applicableAllowanceResponse);
            if (!allowancesUsed) {
                throw new BurnError_1.UseAllowancesFailedError(tokenQuantity.quantity, tokenQuantity.tokenInstanceKey.toStringKey(), owner);
            }
        }
        if (tokenInstance.isNonFungible && !tokenQuantity.quantity.isEqualTo(1)) {
            const quantity = tokenQuantity.quantity.toFixed();
            const tokenInstanceKey = api_1.TokenInstanceKey.nftKey(tokenInstance, tokenInstance.instance).toStringKey();
            const message = `NFT quantity of ${tokenInstanceKey} must equal 1, but got ${quantity}`;
            throw new api_1.ValidationFailedError(message, { tokenInstanceKey, quantity });
        }
        const decimalPlaces = (_a = tokenQuantity.quantity.decimalPlaces()) !== null && _a !== void 0 ? _a : 0;
        if (decimalPlaces > tokenClass.decimals) {
            throw new token_1.InvalidDecimalError(tokenQuantity.quantity, tokenClass.decimals);
        }
        const userBalance = await (0, balances_1.fetchOrCreateBalance)(ctx, owner, tokenInstanceClassKey);
        if (tokenInstance.isNonFungible) {
            userBalance.ensureCanRemoveInstance(tokenInstance.instance, ctx.txUnixTime).remove();
        }
        else {
            userBalance.ensureCanSubtractQuantity(tokenQuantity.quantity, ctx.txUnixTime).subtract();
        }
        const newBurn = await createTokenBurn(ctx, owner, tokenQuantity.tokenInstanceKey, tokenQuantity.quantity);
        const newBurnCounter = await createTokenBurnCounter(ctx, newBurn);
        await (0, utils_1.putChainObject)(ctx, userBalance);
        await (0, utils_1.putChainObject)(ctx, newBurn);
        await (0, utils_1.putRangedChainObject)(ctx, newBurnCounter);
        burnResponses.push(newBurn);
    }
    return burnResponses;
}
exports.burnTokens = burnTokens;
