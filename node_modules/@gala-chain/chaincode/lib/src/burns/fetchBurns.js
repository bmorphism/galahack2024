"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchKnownBurnCount = exports.fetchBurns = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const utils_1 = require("../utils");
// This will return the list sorted by creation date ascending (oldest first)
async function fetchBurns(ctx, data) {
    var _a;
    const queryParams = (0, utils_1.takeUntilUndefined)(data.burnedBy, data.collection, data.category, data.type, data.additionalKey, data.instance, (_a = data.created) === null || _a === void 0 ? void 0 : _a.toString());
    let results = await (0, utils_1.getObjectsByPartialCompositeKey)(ctx, api_1.TokenBurn.INDEX_KEY, queryParams, api_1.TokenBurn);
    // Sort the items ascending by date
    results = results.sort((a, b) => (a.created < b.created ? -1 : 1));
    return results;
}
exports.fetchBurns = fetchBurns;
async function fetchKnownBurnCount(ctx, token) {
    const startTimeOffset = (0, utils_1.inverseTime)(ctx, utils_1.blockTimeout);
    const keyLen = utils_1.inverseKeyLength;
    const startKey = [
        api_1.TokenBurnCounter.INDEX_KEY,
        token.collection,
        token.category,
        token.type,
        token.additionalKey,
        startTimeOffset,
        "".padStart(keyLen, "0")
    ].join(api_1.ChainObject.MIN_UNICODE_RUNE_VALUE);
    const endKey = [
        api_1.TokenBurnCounter.INDEX_KEY,
        token.collection,
        token.category,
        token.type,
        token.additionalKey,
        "".padStart(keyLen, "z"),
        "".padStart(keyLen, "z")
    ].join(api_1.ChainObject.MIN_UNICODE_RUNE_VALUE);
    const iterator = ctx.stub.getStateByRange(startKey, endKey);
    let seekingFirstResult = true;
    let resultsCount = 0;
    const minResults = utils_1.lookbackTxCount;
    const previousRequests = [];
    try {
        for await (const kv of iterator) {
            if (!seekingFirstResult && resultsCount >= minResults) {
                break;
            }
            if (kv.value) {
                const stringResult = Buffer.from(kv.value).toString("utf8");
                const entry = api_1.RangedChainObject.deserialize(api_1.TokenBurnCounter, stringResult);
                // timeKey is a string padded with leading zeros. BigNumber will parse into an integer.
                const entryTime = new bignumber_js_1.default(entry.timeKey);
                seekingFirstResult = false;
                resultsCount++;
                // inverted timeKeys read most recent first; using unshift sorts a new array as oldest first.
                // essentially, we rewind the tape and then play it forward.
                // covering the following possible scensarios:
                //     a) no results yet - empty array, start with zero below.
                //     b) no recent results. continue back toward the beginning of the ledger until we find at least one.
                //     c) recent results. Get all results within two past block spans to cover any missing timestamp gaps from concurrent recent transactions.
                previousRequests.unshift(entry);
            }
        }
    }
    catch (e) {
        throw new Error(`Failed to get iterator for getStateByRange with key: ${startKey}, ${iterator}, ${e}`);
    }
    let startingKnownBurnsCount = new bignumber_js_1.default("0");
    let updatedKnownBurnsCount = new bignumber_js_1.default("0");
    let firstResult = true;
    for (const entry of previousRequests) {
        if (firstResult && entry.totalKnownBurnsCount.isGreaterThan(startingKnownBurnsCount)) {
            // establish base line for first result
            startingKnownBurnsCount = entry.totalKnownBurnsCount;
            updatedKnownBurnsCount = new bignumber_js_1.default(entry.totalKnownBurnsCount);
        }
        firstResult = false;
        updatedKnownBurnsCount = updatedKnownBurnsCount.plus(entry.quantity);
    }
    return updatedKnownBurnsCount;
}
exports.fetchKnownBurnCount = fetchKnownBurnCount;
