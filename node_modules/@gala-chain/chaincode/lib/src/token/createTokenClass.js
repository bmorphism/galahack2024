"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTokenClass = void 0;
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const types_1 = require("../types");
const utils_1 = require("../utils");
const TokenError_1 = require("./TokenError");
const TokenError_2 = require("./TokenError");
async function createTokenClass(ctx, params) {
    if (params.isNonFungible && params.decimals !== 0) {
        throw new TokenError_1.NftDecimalError(params.decimals);
    }
    const newToken = await (0, types_1.createValidChainObject)(api_1.TokenClass, {
        network: params.network,
        collection: params.tokenClass.collection,
        category: params.tokenClass.category,
        type: params.tokenClass.type,
        additionalKey: params.tokenClass.additionalKey,
        isNonFungible: params.isNonFungible,
        decimals: params.decimals,
        name: params.name,
        symbol: params.symbol,
        description: params.description,
        rarity: params.rarity,
        image: params.image,
        metadataAddress: params.metadataAddress,
        contractAddress: params.contractAddress,
        maxSupply: params.maxSupply,
        maxCapacity: params.maxCapacity,
        totalMintAllowance: params.totalMintAllowance,
        totalSupply: params.totalSupply,
        totalBurned: params.totalBurned,
        authorities: params.authorities
    });
    // Token ID cannot be duplicated
    // Make sure the ID is not duplicated across networks by only querying for ID
    const tokenAlreadyExists = await (0, utils_1.objectExists)(ctx, newToken.getCompositeKey());
    if (tokenAlreadyExists) {
        throw new TokenError_2.TokenAlreadyExistsError(newToken.getCompositeKey());
    }
    // If it's a fungible token, make the default instance for it
    if (!newToken.isNonFungible) {
        const defaultInstance = await (0, types_1.createValidChainObject)(api_1.TokenInstance, {
            collection: newToken.collection,
            category: newToken.category,
            type: newToken.type,
            additionalKey: newToken.additionalKey,
            instance: api_1.TokenInstance.FUNGIBLE_TOKEN_INSTANCE,
            isNonFungible: false
        });
        await (0, utils_1.putChainObject)(ctx, defaultInstance);
    }
    // Save token to chain
    await (0, utils_1.putChainObject)(ctx, newToken);
    // Return token ID
    return await api_1.TokenClass.buildClassKeyObject(newToken);
}
exports.createTokenClass = createTokenClass;
