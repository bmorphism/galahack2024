"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transferToken = void 0;
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const allowances_1 = require("../allowances");
const balances_1 = require("../balances");
const token_1 = require("../token");
const fetchTokenClasses_1 = require("../token/fetchTokenClasses");
const utils_1 = require("../utils");
const TransferError_1 = require("./TransferError");
async function transferToken(ctx, { from, to, tokenInstanceKey, quantity, allowancesToUse, authorizedOnBehalf }) {
    var _a, _b;
    const msg = `TransferToken ${tokenInstanceKey.toStringKey()} from ${from !== null && from !== void 0 ? from : "?"} to ${to}, ` +
        `quantity: ${quantity.toFixed()}, allowancesToUse: ${allowancesToUse.length}.`;
    ctx.logger.info(msg);
    if (from === to) {
        throw new TransferError_1.SameSenderAndRecipientError(from, to);
    }
    const tokenInstance = await (0, token_1.fetchTokenInstance)(ctx, tokenInstanceKey);
    const tokenClass = await (0, fetchTokenClasses_1.fetchTokenClass)(ctx, tokenInstanceKey);
    const decimalPlaces = (_a = quantity.decimalPlaces()) !== null && _a !== void 0 ? _a : 0;
    if (decimalPlaces > tokenClass.decimals) {
        throw new token_1.InvalidDecimalError(quantity, tokenClass.decimals);
    }
    // Determine if user acts as a bridge
    const callingOnBehalf = (_b = authorizedOnBehalf === null || authorizedOnBehalf === void 0 ? void 0 : authorizedOnBehalf.callingOnBehalf) !== null && _b !== void 0 ? _b : ctx.callingUser;
    // If a user is trying to transfer tokens on someone else's behalf, we need to verify and use allowances
    if (from !== callingOnBehalf) {
        const msg = `Transfer executed on behalf of another user (fromPerson: ${from}, callingUser: ${callingOnBehalf})`;
        ctx.logger.info(msg);
        await (0, allowances_1.verifyAndUseAllowances)(ctx, from, tokenInstanceKey, quantity, tokenInstance, callingOnBehalf, api_1.AllowanceType.Transfer, allowancesToUse);
    }
    const fromPersonBalance = await (0, balances_1.fetchOrCreateBalance)(ctx, from, tokenInstanceKey);
    const toPersonBalance = await (0, balances_1.fetchOrCreateBalance)(ctx, to, tokenInstanceKey);
    if (tokenInstance.isNonFungible) {
        fromPersonBalance.ensureCanRemoveInstance(tokenInstance.instance, ctx.txUnixTime).remove();
        toPersonBalance.ensureCanAddInstance(tokenInstance.instance).add();
    }
    else {
        fromPersonBalance.ensureCanSubtractQuantity(quantity, ctx.txUnixTime).subtract();
        toPersonBalance.ensureCanAddQuantity(quantity).add();
    }
    await (0, utils_1.putChainObject)(ctx, fromPersonBalance);
    await (0, utils_1.putChainObject)(ctx, toPersonBalance);
    if (tokenInstance.isNonFungible) {
        tokenInstance.owner = to;
        await (0, utils_1.putChainObject)(ctx, tokenInstance);
    }
    return [fromPersonBalance, toPersonBalance];
}
exports.transferToken = transferToken;
