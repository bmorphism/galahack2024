"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGalaChainStub = void 0;
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const FabricIterable_1 = require("./FabricIterable");
/**
 * The main purpose of this class is to keep the state clean when the transaction fails. In this
 * case (1) we don't want to save any keys and (2) we want to have all errors caught to produce
 * meaningful error messages. However, when transaction does not end uncaught error, Fabric updates
 * the state. It may lead to corrupted state. That's why we use this class to cache write operations
 * and allow the @GalaTransaction call `flush` method after the successful transaction. We want to
 * save changes only if the transaction succeeds.
 *
 * Also, this class provides `getCachedState` method to be used to access values that have been
 * already read or updated within current chaincode call.
 *
 * This class implements all methods from ChaincodeStub that changes the state to forbid actually
 * changing the state without flushing. Leaving some methods not supported is intentional.
 */
class StubCache {
    constructor(stub) {
        this.stub = stub;
        this.writes = {};
        this.reads = {};
        this.deletes = {};
    }
    async getCachedState(key) {
        if (key in this.deletes) {
            return new Uint8Array();
        }
        if (key in this.writes) {
            return this.writes[key];
        }
        if (key in this.reads) {
            return this.reads[key];
        }
        const result = await this.stub.getState(key);
        this.reads[key] = result;
        return result;
    }
    getCachedStateByPartialCompositeKey(objectType, attributes) {
        const partialCompositeKey = this.stub.createCompositeKey(objectType, attributes);
        const cached = Object.entries({ ...this.reads, ...this.writes })
            .filter(([k]) => k.startsWith(partialCompositeKey))
            .map(([k, v]) => ({ key: k, value: v }));
        const keysToExclude = new Set(cached.map((kv) => kv.key).concat(Object.keys(this.deletes)));
        const state = this.stub.getStateByPartialCompositeKey(objectType, attributes);
        const filteredState = (0, FabricIterable_1.filter)((kv) => !keysToExclude.has(kv.key), state[Symbol.asyncIterator]());
        return (0, FabricIterable_1.fabricIterable)((0, FabricIterable_1.prepend)(cached, filteredState));
    }
    putState(key, value) {
        this.writes[key] = value;
        if (key in this.deletes) {
            delete this.deletes[key];
        }
        if (key in this.reads) {
            delete this.reads[key];
        }
        return Promise.resolve();
    }
    deleteState(key) {
        this.deletes[key] = true;
        if (key in this.writes) {
            delete this.writes[key];
        }
        if (key in this.reads) {
            delete this.reads[key];
        }
        return Promise.resolve();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setStateValidationParameter(key, ep) {
        throw new api_1.NotImplementedError("setStateValidationParameter is not supported");
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setEvent(name, payload) {
        throw new api_1.NotImplementedError("setEvent is not supported");
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    putPrivateData(collection, key, value) {
        throw new api_1.NotImplementedError("putPrivateData is not supported");
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    deletePrivateData(collection, key) {
        throw new api_1.NotImplementedError("deletePrivateData is not supported");
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setPrivateDataValidationParameter(collection, key, ep) {
        throw new api_1.NotImplementedError("setPrivateDataValidationParameter is not supported");
    }
    async flushWrites() {
        const deleteOps = Object.keys(this.deletes).map((key) => this.stub.deleteState(key));
        const putOps = Object.entries(this.writes).map(([key, value]) => this.stub.putState(key, value));
        await Promise.all(deleteOps);
        await Promise.all(putOps);
    }
}
const createGalaChainStub = (stub) => {
    const cachedWrites = new StubCache(stub);
    const proxyHandler = {
        get: function (target, name) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            return name in cachedWrites ? cachedWrites[name] : target[name];
        }
    };
    // Note: Proxy is slightly slower than direct object access, but it is recommended to use
    // it here, since we are not able to implement all ChaincodeStub internals that should be
    // handled. It is more reliable to pass the missing calls to target object. It is also
    // easier to test it.
    return new Proxy(stub, proxyHandler);
};
exports.createGalaChainStub = createGalaChainStub;
