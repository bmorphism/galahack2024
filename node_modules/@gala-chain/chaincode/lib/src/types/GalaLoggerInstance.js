"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GalaLoggerInstanceImpl = exports.createLoggerInstance = exports.winstonConfig = exports.createJsonLogger = exports.createReadableLogger = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const dd_trace_1 = tslib_1.__importDefault(require("dd-trace"));
const formats_1 = tslib_1.__importDefault(require("dd-trace/ext/formats"));
const nanoid_1 = require("nanoid");
const os_1 = tslib_1.__importDefault(require("os"));
const process_1 = require("process");
const winston = tslib_1.__importStar(require("winston"));
// eslint-disable-next-line @typescript-eslint/no-var-requires
const logger = require("fabric-contract-api/lib/logger");
const print = winston.format.printf((param) => {
    const { level, message } = param;
    const timestamp = param.timestamp;
    const context = param.context;
    const stack = param.stack;
    // If an error and has a stack trace
    if (stack instanceof Array && stack.length) {
        return `${timestamp} ${level} [${context}] ${stack[0]}`;
    }
    return `${timestamp} ${level} [${context}] ${message}`;
});
const readableFormat = winston.format.combine(winston.format.timestamp(), winston.format.colorize(), winston.format.errors({ stack: true }), winston.format.align(), print);
function createReadableLogger(logLevel = "info") {
    return {
        level: logLevel,
        format: readableFormat,
        transports: [new winston.transports.Console()]
    };
}
exports.createReadableLogger = createReadableLogger;
function createJsonLogger(logLevel = "warn") {
    return {
        level: logLevel,
        format: winston.format.json(),
        transports: [new winston.transports.Console()],
        exceptionHandlers: [new winston.transports.Console()],
        rejectionHandlers: [new winston.transports.Console()],
        handleExceptions: true,
        handleRejections: true
    };
}
exports.createJsonLogger = createJsonLogger;
function determineLogLevel() {
    var _a, _b;
    const LOG_LEVEL = (_b = (_a = process.env) === null || _a === void 0 ? void 0 : _a.LOG_LEVEL) === null || _b === void 0 ? void 0 : _b.toLowerCase();
    const logLevels = ["error", "warn", "info", "verbose", "debug"];
    if (typeof LOG_LEVEL === "string" && logLevels.includes(LOG_LEVEL)) {
        return LOG_LEVEL;
    }
    return "debug";
}
function winstonConfig() {
    const { JSON_LOGS } = process.env;
    const LOG_LEVEL = determineLogLevel();
    let logger;
    if ((JSON_LOGS === null || JSON_LOGS === void 0 ? void 0 : JSON_LOGS.toLowerCase()) === "true") {
        logger = createJsonLogger(LOG_LEVEL);
    }
    else {
        logger = createReadableLogger(LOG_LEVEL);
    }
    return logger;
}
exports.winstonConfig = winstonConfig;
const createLoggerInstance = (ctx) => logger.getLogger(ctx.stub.getFunctionAndParameters().fcn);
exports.createLoggerInstance = createLoggerInstance;
class GalaLoggerInstanceImpl {
    constructor(ctx) {
        this.uniqueId = (0, nanoid_1.nanoid)();
        this.createdAt = process_1.hrtime.bigint();
        this.ctx = ctx;
        this.instance = (0, exports.createLoggerInstance)(ctx);
        this.instance.configure(winstonConfig());
        const channelId = ctx.stub.getChannelID();
        const shortTxId = ctx.stub.getTxID().substring(0, 8);
        this.prefix = `[${channelId}-${shortTxId}]`;
    }
    get commonProcess() {
        return {
            host: os_1.default.hostname(),
            uptime: this.uptime,
            loadAvg: os_1.default.loadavg()
        };
    }
    get commonContext() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const fcn = (_c = (_b = (_a = this.ctx) === null || _a === void 0 ? void 0 : _a.stub) === null || _b === void 0 ? void 0 : _b.getFunctionAndParameters) === null || _c === void 0 ? void 0 : _c.call(_b);
        return {
            uniqueId: this.uniqueId,
            channelId: (_d = this.ctx.stub) === null || _d === void 0 ? void 0 : _d.getChannelID(),
            creator: (_f = (_e = this.ctx.stub) === null || _e === void 0 ? void 0 : _e.getCreator()) === null || _f === void 0 ? void 0 : _f.mspid,
            txId: (_h = (_g = this.ctx) === null || _g === void 0 ? void 0 : _g.stub) === null || _h === void 0 ? void 0 : _h.getTxID(),
            chaincode: fcn === null || fcn === void 0 ? void 0 : fcn.fcn,
            parameters: fcn === null || fcn === void 0 ? void 0 : fcn.params,
            createdAt: this.createdAtDate
        };
    }
    get commonMeta() {
        return {
            context: this.commonContext,
            process: this.commonProcess
        };
    }
    get timeElapsed() {
        const elapsed = this.getElapsedNanos();
        return `${elapsed / BigInt(1e6)}ms`;
    }
    get uptime() {
        var _a;
        return `${(_a = (process.hrtime.bigint() / BigInt(1e9))) === null || _a === void 0 ? void 0 : _a.toString()}s`;
    }
    get createdAtDate() {
        return new Date(Date.parse((this.createdAt / BigInt(1e6)).toString()));
    }
    setLevel(level) {
        logger.setLevel(level);
    }
    getLogger(name) {
        return logger.getLogger(name);
    }
    error(message) {
        this.log("error", message);
    }
    warn(message) {
        this.log("warn", message);
    }
    info(message) {
        this.log("info", message);
    }
    debug(message) {
        this.log("debug", message);
    }
    log(level, msg) {
        var _a;
        const timestamp = Date.now();
        const record = typeof msg === "string"
            ? { timestamp, level, message: `${this.prefix} ${msg}` }
            : { timestamp, ...msg, level, message: msg["message"] };
        const spanContext = (_a = dd_trace_1.default.scope().active()) === null || _a === void 0 ? void 0 : _a.context();
        if (spanContext) {
            dd_trace_1.default.inject(spanContext, formats_1.default.LOG, record);
        }
        this.instance.log(record);
    }
    getElapsedNanos() {
        return process_1.hrtime.bigint() - this.createdAt;
    }
    logTimeline(timelineActionDescription, context, metaData, error = null) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const args = {
            description: timelineActionDescription,
            requestId: this.uniqueId,
            elapsed: `${this.timeElapsed}`,
            method: [(_b = (_a = this.ctx) === null || _a === void 0 ? void 0 : _a.stub) === null || _b === void 0 ? void 0 : _b.getChannelID(), (_e = (_d = (_c = this.ctx) === null || _c === void 0 ? void 0 : _c.stub) === null || _d === void 0 ? void 0 : _d.getFunctionAndParameters) === null || _e === void 0 ? void 0 : _e.call(_d).fcn].join(":")
        };
        // special case for cron call to prevent bloated logs
        const isContractAPIRequest = (_h = (_g = (_f = this.ctx) === null || _f === void 0 ? void 0 : _f.stub) === null || _g === void 0 ? void 0 : _g.getFunctionAndParameters()) === null || _h === void 0 ? void 0 : _h.fcn.endsWith("GetContractAPI");
        if (!isContractAPIRequest) {
            args.metaData = metaData;
            args.info = this.commonMeta;
        }
        const level = error ? "error" : "info";
        const logData = {
            timestamp: Date.now(),
            context,
            message: JSON.stringify(args),
            stack: error === null || error === void 0 ? void 0 : error.stack
        };
        this.log(level, logData);
    }
}
exports.GalaLoggerInstanceImpl = GalaLoggerInstanceImpl;
