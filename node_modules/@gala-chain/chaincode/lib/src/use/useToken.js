"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useToken = void 0;
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const allowances_1 = require("../allowances");
const balances_1 = require("../balances");
const token_1 = require("../token");
const utils_1 = require("../utils");
const UseError_1 = require("./UseError");
async function useToken(ctx, { owner, inUseBy, tokenInstanceKey, quantity, allowancesToUse, authorizedOnBehalf }) {
    var _a;
    const msg = `UseToken ${tokenInstanceKey.toStringKey()} of ${owner !== null && owner !== void 0 ? owner : "?"}, ` +
        `inUseBy: ${inUseBy}, allowancesToUse: ${allowancesToUse.length}`;
    ctx.logger.info(msg);
    if (tokenInstanceKey.isFungible()) {
        throw new api_1.NotImplementedError("UseToken is not supported for fungible tokens", {
            tokenInstanceKey: tokenInstanceKey.toStringKey()
        });
    }
    if (!quantity.isEqualTo(1)) {
        throw new UseError_1.NftInvalidQuantityUseError(quantity, tokenInstanceKey.toStringKey());
    }
    // Get the token instance
    const tokenInstance = await (0, token_1.fetchTokenInstance)(ctx, tokenInstanceKey);
    // Determine if user acts as a bridge
    const callingOnBehalf = (_a = authorizedOnBehalf === null || authorizedOnBehalf === void 0 ? void 0 : authorizedOnBehalf.callingOnBehalf) !== null && _a !== void 0 ? _a : ctx.callingUser;
    // If a user is trying to use tokens on someone else's behalf, we need to verify and use allowances
    if (owner !== callingOnBehalf) {
        const msg = `UseToken executed on behalf of another user (fromPerson: ${owner}, callingUser: ${callingOnBehalf})`;
        ctx.logger.info(msg);
        await (0, allowances_1.verifyAndUseAllowances)(ctx, owner, tokenInstanceKey, quantity, tokenInstance, callingOnBehalf, api_1.AllowanceType.Use, allowancesToUse);
    }
    // Use token
    const balance = await (0, balances_1.fetchOrCreateBalance)(ctx, owner, tokenInstanceKey.getTokenClassKey());
    const hold = await api_1.TokenHold.createValid({
        createdBy: callingOnBehalf,
        instanceId: tokenInstance.instance,
        quantity: quantity,
        created: ctx.txUnixTime,
        expires: 0,
        name: undefined,
        lockAuthority: undefined
    });
    balance.ensureCanUseInstance(hold, ctx.txUnixTime).use();
    await (0, utils_1.putChainObject)(ctx, balance);
    return balance;
}
exports.useToken = useToken;
