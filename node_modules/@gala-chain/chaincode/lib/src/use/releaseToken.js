"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.releaseToken = void 0;
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const balances_1 = require("../balances");
const token_1 = require("../token");
const fetchTokenClasses_1 = require("../token/fetchTokenClasses");
const utils_1 = require("../utils");
const UseError_1 = require("./UseError");
async function releaseToken(ctx, { tokenInstanceKey }) {
    if (tokenInstanceKey.isFungible()) {
        throw new api_1.NotImplementedError("RealeaseToken is not supported for fungible tokens", {
            instanceKey: tokenInstanceKey.toStringKey()
        });
    }
    // owner is always present for NFT instances
    const tokenInstance = await (0, token_1.fetchTokenInstance)(ctx, tokenInstanceKey);
    const owner = tokenInstance.owner;
    const balance = await (0, balances_1.fetchOrCreateBalance)(ctx, owner, tokenInstanceKey.getTokenClassKey());
    const applicableHold = balance.findInUseHold(tokenInstanceKey.instance, ctx.txUnixTime);
    // determine if user is authorized to release
    const authorized = (applicableHold === null || applicableHold === void 0 ? void 0 : applicableHold.createdBy) === ctx.callingUser || balance.owner === ctx.callingUser;
    // if calling user is not authorized, always token class authority can release
    if (!authorized) {
        const tokenClass = await (0, fetchTokenClasses_1.fetchTokenClass)(ctx, tokenInstanceKey);
        const isTokenAuthority = tokenClass.authorities.includes(ctx.callingUser);
        if (!isTokenAuthority) {
            throw new UseError_1.ReleaseForbiddenUserError(ctx.callingUser, tokenInstanceKey.toStringKey());
        }
    }
    if (applicableHold === undefined) {
        // we assume use may have expired or been released already
        return balance;
    }
    balance.ensureCanReleaseInstance(applicableHold.instanceId, undefined, ctx.txUnixTime).release();
    await (0, utils_1.putChainObject)(ctx, balance);
    return balance;
}
exports.releaseToken = releaseToken;
