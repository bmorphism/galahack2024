"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublicKeyContract = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const fabric_contract_api_1 = require("fabric-contract-api");
const services_1 = require("../services");
const PublicKeyError_1 = require("../services/PublicKeyError");
const types_1 = require("../types");
const GalaContract_1 = require("./GalaContract");
const GalaTransaction_1 = require("./GalaTransaction");
let version = "0.0.0";
try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    version = require("../../../package.json").version;
}
catch (e) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    version = require("../../package.json").version;
}
let PublicKeyContract = class PublicKeyContract extends GalaContract_1.GalaContract {
    constructor() {
        super("PublicKeyContract", version);
    }
    async registerUser(ctx, providedPkHex, ethAddress, userAlias) {
        const currPublicKey = await services_1.PublicKeyService.getPublicKey(ctx, userAlias);
        // If we are migrating a legacy user to new flow, the public key should match
        if (currPublicKey !== undefined) {
            const nonCompactCurrPubKey = api_1.signatures.getNonCompactHexPublicKey(currPublicKey.publicKey);
            if (nonCompactCurrPubKey !== providedPkHex) {
                throw new PublicKeyError_1.PkMismatchError(userAlias);
            }
        }
        // If User Profile already exists on chain for this ethereum address, we should not allow registering the same user again
        const existingUserProfile = await services_1.PublicKeyService.getUserProfile(ctx, ethAddress);
        if (existingUserProfile !== undefined) {
            throw new PublicKeyError_1.ProfileExistsError(ethAddress, existingUserProfile.alias);
        }
        // supports legacy flow (required for backwards compatibility)
        await services_1.PublicKeyService.putPublicKey(ctx, providedPkHex, userAlias);
        // for the new flow, we need to store the user profile separately
        await services_1.PublicKeyService.putUserProfile(ctx, ethAddress, userAlias);
        return api_1.GalaChainResponse.Success(userAlias);
    }
    async updatePublicKey(ctx, newPkHex, newEthAddress) {
        const userAlias = ctx.callingUser;
        // fetch old public key for finding old user profile
        const oldPublicKey = await services_1.PublicKeyService.getPublicKey(ctx, ctx.callingUser);
        if (oldPublicKey === undefined) {
            throw new PublicKeyError_1.PkNotFoundError(userAlias);
        }
        // need to fetch userProfile from old address
        const oldNonCompactPublicKey = api_1.signatures.getNonCompactHexPublicKey(oldPublicKey.publicKey);
        const oldEthAddress = api_1.signatures.getEthAddress(oldNonCompactPublicKey);
        const userProfile = await services_1.PublicKeyService.getUserProfile(ctx, oldEthAddress);
        // Note: we don't throw an error if userProfile is undefined in order to support legacy users with unsaved profiles
        if (userProfile !== undefined) {
            // remove old user profile
            await services_1.PublicKeyService.deleteUserProfile(ctx, oldEthAddress);
        }
        // update Public Key, and add user profile under new eth address
        await services_1.PublicKeyService.putPublicKey(ctx, newPkHex, userAlias);
        await services_1.PublicKeyService.putUserProfile(ctx, newEthAddress, userAlias);
    }
    async GetMyProfile(ctx, dto) {
        const ethAddress = await new Promise((resolve) => resolve(ctx.callingUserEthAddress)).catch((e) => {
            const newError = new api_1.NotImplementedError("Function is not supported for legacy auth");
            throw api_1.ChainError.map(e, api_1.ErrorCode.UNAUTHORIZED, newError);
        });
        const profile = await services_1.PublicKeyService.getUserProfile(ctx, ethAddress);
        if (profile === undefined) {
            throw new api_1.NotFoundError(`UserProfile not found for ${ctx.callingUser}`, {
                signature: dto.signature,
                user: ctx.callingUser
            });
        }
        return api_1.GalaChainResponse.Success(profile);
    }
    async RegisterUser(ctx, dto) {
        if (!dto.user.startsWith("client|")) {
            const message = `User alias should start with 'client|', but got: ${dto.user}`;
            throw new api_1.ValidationFailedError(message);
        }
        const providedPkHex = api_1.signatures.getNonCompactHexPublicKey(dto.publicKey);
        const ethAddress = api_1.signatures.getEthAddress(providedPkHex);
        const userAlias = dto.user;
        return this.registerUser(ctx, providedPkHex, ethAddress, userAlias);
    }
    async RegisterEthUser(ctx, dto) {
        const providedPkHex = api_1.signatures.getNonCompactHexPublicKey(dto.publicKey);
        const ethAddress = api_1.signatures.getEthAddress(providedPkHex);
        const userAlias = `eth|${ethAddress}`;
        return this.registerUser(ctx, providedPkHex, ethAddress, userAlias);
    }
    async UpdatePublicKey(ctx, dto) {
        const providedPkHex = api_1.signatures.getNonCompactHexPublicKey(dto.publicKey);
        const ethAddress = api_1.signatures.getEthAddress(providedPkHex);
        await this.updatePublicKey(ctx, providedPkHex, ethAddress);
        return api_1.GalaChainResponse.Success(undefined);
    }
    async GetPublicKey(ctx, dto) {
        var _a;
        const user = (_a = dto.user) !== null && _a !== void 0 ? _a : ctx.callingUser;
        const publicKey = await services_1.PublicKeyService.getPublicKey(ctx, user);
        if (publicKey === undefined) {
            throw new PublicKeyError_1.PkNotFoundError(user);
        }
        return api_1.GalaChainResponse.Success(publicKey);
    }
    async VerifySignature(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ctx, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    dto) {
        // do nothing - verification is handled by @GalaTransaction decorator
        return api_1.GalaChainResponse.Success(undefined);
    }
};
exports.PublicKeyContract = PublicKeyContract;
tslib_1.__decorate([
    (0, GalaTransaction_1.GalaTransaction)({
        type: GalaTransaction_1.EVALUATE,
        in: api_1.GetMyProfileDto,
        verifySignature: true,
        description: "Returns profile for the calling user. " +
            "Since the profile contains also eth address of the user, this method is supported only for signature based authentication."
    }),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [types_1.GalaChainContext,
        api_1.GetMyProfileDto]),
    tslib_1.__metadata("design:returntype", Promise)
], PublicKeyContract.prototype, "GetMyProfile", null);
tslib_1.__decorate([
    (0, GalaTransaction_1.GalaTransaction)({
        type: GalaTransaction_1.SUBMIT,
        in: api_1.RegisterUserDto,
        out: "string",
        description: "Registers a new user on chain under provided user alias.",
        allowedOrgs: ["CuratorOrg"],
        verifySignature: true
    }),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [types_1.GalaChainContext, api_1.RegisterUserDto]),
    tslib_1.__metadata("design:returntype", Promise)
], PublicKeyContract.prototype, "RegisterUser", null);
tslib_1.__decorate([
    (0, GalaTransaction_1.GalaTransaction)({
        type: GalaTransaction_1.SUBMIT,
        in: api_1.RegisterEthUserDto,
        out: "string",
        description: "Registers a new user on chain under alias derived from eth address.",
        allowedOrgs: ["CuratorOrg"],
        verifySignature: true
    }),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [types_1.GalaChainContext,
        api_1.RegisterEthUserDto]),
    tslib_1.__metadata("design:returntype", Promise)
], PublicKeyContract.prototype, "RegisterEthUser", null);
tslib_1.__decorate([
    (0, GalaTransaction_1.GalaTransaction)({
        type: GalaTransaction_1.SUBMIT,
        in: api_1.UpdatePublicKeyDto,
        description: "Updates public key for the calling user.",
        verifySignature: true
    }),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [types_1.GalaChainContext,
        api_1.UpdatePublicKeyDto]),
    tslib_1.__metadata("design:returntype", Promise)
], PublicKeyContract.prototype, "UpdatePublicKey", null);
tslib_1.__decorate([
    (0, GalaTransaction_1.GalaTransaction)({
        type: GalaTransaction_1.EVALUATE,
        in: api_1.GetPublicKeyDto,
        out: api_1.PublicKey,
        description: "[Deprecated] Returns public key for the user"
    }),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [types_1.GalaChainContext,
        api_1.GetPublicKeyDto]),
    tslib_1.__metadata("design:returntype", Promise)
], PublicKeyContract.prototype, "GetPublicKey", null);
tslib_1.__decorate([
    (0, GalaTransaction_1.GalaTransaction)({
        type: GalaTransaction_1.EVALUATE,
        in: api_1.ChainCallDTO,
        description: "Verifies signature of the DTO signed with caller's private key to be verified with user's public key saved on chain.",
        verifySignature: true
    }),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [types_1.GalaChainContext,
        api_1.ChainCallDTO]),
    tslib_1.__metadata("design:returntype", Promise)
], PublicKeyContract.prototype, "VerifySignature", null);
exports.PublicKeyContract = PublicKeyContract = tslib_1.__decorate([
    (0, fabric_contract_api_1.Info)({
        title: "PublicKeyContract",
        description: "Contract for managing public keys for accounts"
    }),
    tslib_1.__metadata("design:paramtypes", [])
], PublicKeyContract);
