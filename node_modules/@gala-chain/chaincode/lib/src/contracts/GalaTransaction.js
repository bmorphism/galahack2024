"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GalaTransaction = exports.EVALUATE = exports.SUBMIT = exports.Evaluate = exports.Submit = void 0;
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const fabric_contract_api_1 = require("fabric-contract-api");
const util_1 = require("util");
const services_1 = require("../services");
const GalaContractApi_1 = require("./GalaContractApi");
const authorize_1 = require("./authorize");
const legacyClientAccountId_1 = require("./legacyClientAccountId");
// All DTOs need to be registered in the application, including super classes. Otherwise, chaincode
// containers will fail to start. Below we register just some base classes. Actual DTO classes are
// registered inside decorator factory.
//
(0, fabric_contract_api_1.Object)()(api_1.ChainCallDTO);
// Note: it is just a metadata, you cannot effectively forbid to submit the transaction
// (you can, however make it readonly by passing random value to the result or manipulating the context)
var GalaTransactionType;
(function (GalaTransactionType) {
    GalaTransactionType[GalaTransactionType["EVALUATE"] = 0] = "EVALUATE";
    GalaTransactionType[GalaTransactionType["SUBMIT"] = 1] = "SUBMIT";
})(GalaTransactionType || (GalaTransactionType = {}));
const { SUBMIT, EVALUATE } = GalaTransactionType;
exports.SUBMIT = SUBMIT;
exports.EVALUATE = EVALUATE;
function isArrayOut(x) {
    return typeof x === "object" && "arrayOf" in x;
}
function Submit(options) {
    return GalaTransaction({ ...options, type: SUBMIT, verifySignature: true });
}
exports.Submit = Submit;
function Evaluate(options) {
    return GalaTransaction({ ...options, type: EVALUATE, verifySignature: true });
}
exports.Evaluate = Evaluate;
function GalaTransaction(options) {
    var _a;
    // Register the DTO class to be passed
    if (options.in !== undefined) {
        (0, fabric_contract_api_1.Object)()(options.in);
    }
    if (options.type === SUBMIT && !options.verifySignature && !((_a = options.allowedOrgs) === null || _a === void 0 ? void 0 : _a.length)) {
        const message = `SUBMIT transaction must have either verifySignature or allowedOrgs defined`;
        throw new api_1.UnauthorizedError(message);
    }
    // An actual decorator
    return (target, propertyKey, descriptor) => {
        var _a, _b, _c;
        // Takes the method to wrap
        const method = descriptor.value;
        const className = (_b = (_a = target.constructor) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "UnknownContractClass";
        if ((method === null || method === void 0 ? void 0 : method.name) === undefined) {
            throw new api_1.RuntimeError("Undefined method name for descriptor.value: " + (0, util_1.inspect)(method));
        }
        const loggingContext = `${className}:${(_c = method.name) !== null && _c !== void 0 ? _c : "UnknownMethod"}`;
        // Creates the new method. The first parameter is always ctx, the second,
        // optional one, is a plain dto object. We ignore the rest. This is our
        // convention.
        // eslint-disable-next-line no-param-reassign
        descriptor.value = async function (ctx, dtoPlain) {
            var _a, _b, _c, _d;
            try {
                const metadata = [{ dto: dtoPlain }];
                (_a = ctx === null || ctx === void 0 ? void 0 : ctx.logger) === null || _a === void 0 ? void 0 : _a.logTimeline("Begin Transaction", loggingContext, metadata);
                // Parse & validate - may throw an exception
                const dtoClass = (_b = options.in) !== null && _b !== void 0 ? _b : api_1.ChainCallDTO;
                const dto = !dtoPlain
                    ? undefined
                    : await (0, api_1.parseValidDTO)(dtoClass, dtoPlain);
                // Verify public key signature if needed - throws exception in case of failure
                if ((options === null || options === void 0 ? void 0 : options.verifySignature) || (dto === null || dto === void 0 ? void 0 : dto.signature) !== undefined) {
                    ctx.callingUserData = await (0, authorize_1.authorize)(ctx, dto, (0, legacyClientAccountId_1.legacyClientAccountId)(ctx));
                }
                else {
                    ctx.callingUserData = { alias: (0, legacyClientAccountId_1.legacyClientAccountId)(ctx) }; // TODO consider authorizing all calls
                }
                // Prevent the same transaction from being submitted multiple times
                if (dto === null || dto === void 0 ? void 0 : dto.uniqueKey) {
                    await services_1.UniqueTransactionService.ensureUniqueTransaction(ctx, dto.uniqueKey);
                }
                else if (options.enforceUniqueKey) {
                    throw new api_1.RuntimeError("Missing uniqueKey in transaction dto");
                }
                const argArray = dto ? [ctx, dto] : [ctx];
                // Verify if organization can invoke this method - throws exception in case of failure
                if (options === null || options === void 0 ? void 0 : options.allowedOrgs) {
                    (0, authorize_1.ensureOrganizationIsAllowed)(ctx, options.allowedOrgs);
                }
                if ((options === null || options === void 0 ? void 0 : options.before) !== undefined) {
                    await ((_c = options === null || options === void 0 ? void 0 : options.before) === null || _c === void 0 ? void 0 : _c.apply(this, argArray));
                }
                // Execute the method. Note the contract method is always an async
                // function, so it is safe to do the `await`
                const result = await (method === null || method === void 0 ? void 0 : method.apply(this, argArray));
                const normalizedResult = typeof result === "object" && "Status" in result && typeof result.Status === "number"
                    ? result
                    : api_1.GalaChainResponse.Success(result);
                if ((options === null || options === void 0 ? void 0 : options.after) !== undefined) {
                    await ((_d = options === null || options === void 0 ? void 0 : options.after) === null || _d === void 0 ? void 0 : _d.apply(this, [ctx, dto, normalizedResult]));
                }
                return normalizedResult;
            }
            catch (err) {
                if (ctx.logger) {
                    api_1.ChainError.from(err).logWarn(ctx.logger);
                    ctx.logger.logTimeline("Failed Transaction", loggingContext, [dtoPlain], err);
                }
                // TODO to be considered - since we catch all errors here, failed
                // transaction are saved on chain (including transactions that failed
                // because of dto validation). Do we want it?
                return api_1.GalaChainResponse.Error(err);
            }
        };
        // Update API of contract object
        const isWrite = options.type === GalaTransactionType.SUBMIT;
        (0, GalaContractApi_1.updateApi)(target, {
            isWrite,
            methodName: method.name,
            apiMethodName: options.apiMethodName,
            dtoSchema: options.in === undefined ? undefined : (0, api_1.generateSchema)(options.in),
            description: options.description,
            responseSchema: isArrayOut(options.out)
                ? (0, api_1.generateResponseSchema)(options.out.arrayOf, "array")
                : (0, api_1.generateResponseSchema)(options.out),
            sequence: options.sequence
        });
        // Ensure this is an actual HLF transaction.
        // If this annotation is missing, you cannot call the chaincode method
        (0, fabric_contract_api_1.Transaction)(isWrite)(target, propertyKey);
    };
}
exports.GalaTransaction = GalaTransaction;
