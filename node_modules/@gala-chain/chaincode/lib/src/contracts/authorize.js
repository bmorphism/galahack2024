"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureOrganizationIsAllowed = exports.ensureIsAuthorizedBy = exports.authorize = void 0;
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const services_1 = require("../services");
class MissingSignatureError extends api_1.ValidationFailedError {
    constructor() {
        super("Signature is missing.");
    }
}
class RedundantSignerPublicKeyError extends api_1.ValidationFailedError {
    constructor(recovered, inDto) {
        super("Public key is redundant, when it can be recovered from signature.", { recovered, inDto });
    }
}
class UserNotRegisteredError extends api_1.ValidationFailedError {
    constructor(userId) {
        super(`User ${userId} is not registered.`, { userId });
    }
}
class OrganizationNotAllowedError extends api_1.ForbiddenError {
}
/**
 *
 * @param ctx
 * @param dto
 * @param legacyCAUser fallback user alias to use then the new flow is not applicable
 * @returns User alias of the calling user.
 */
async function authorize(ctx, dto, legacyCAUser) {
    if (!dto || dto.signature === undefined) {
        throw new MissingSignatureError();
    }
    const recoveredPkHex = recoverPublicKey(dto.signature, dto);
    if (recoveredPkHex !== undefined) {
        if (dto.signerPublicKey !== undefined) {
            throw new RedundantSignerPublicKeyError(recoveredPkHex, dto.signerPublicKey);
        }
        return await getUserProfile(ctx, recoveredPkHex); // new flow only
    }
    else if (dto.signerPublicKey !== undefined) {
        const providedPkHex = api_1.signatures.getNonCompactHexPublicKey(dto.signerPublicKey);
        const ethAddress = api_1.signatures.getEthAddress(providedPkHex);
        if (!dto.isSignatureValid(providedPkHex)) {
            throw new services_1.PkInvalidSignatureError(`eth|${ethAddress}`);
        }
        return await getUserProfile(ctx, providedPkHex); // new flow only
    }
    else {
        return await legacyAuthorize(ctx, dto, legacyCAUser); // legacy flow only
    }
}
exports.authorize = authorize;
async function ensureIsAuthorizedBy(ctx, dto, userAlias) {
    const authorized = await authorize(ctx, dto, userAlias);
    if (authorized.alias !== userAlias) {
        throw new api_1.ForbiddenError(`Dto is authorized by ${authorized}, and not by ${userAlias}`, { authorized });
    }
    return authorized;
}
exports.ensureIsAuthorizedBy = ensureIsAuthorizedBy;
async function getUserProfile(ctx, pkHex) {
    const ethAddress = api_1.signatures.getEthAddress(pkHex);
    const profile = await services_1.PublicKeyService.getUserProfile(ctx, ethAddress);
    if (profile === undefined) {
        throw new UserNotRegisteredError(ethAddress);
    }
    return profile;
}
async function legacyAuthorize(ctx, dto, legacyCAUser) {
    const pk = await getSavedPKOrReject(ctx, legacyCAUser);
    if (!dto.isSignatureValid(pk.publicKey)) {
        throw new services_1.PkInvalidSignatureError(legacyCAUser);
    }
    return {
        alias: legacyCAUser,
        ethAddress: undefined
    };
}
function ensureOrganizationIsAllowed(ctx, allowedOrgsMSPs) {
    const userOrg = ctx.clientIdentity.getMSPID();
    const isAllowed = (allowedOrgsMSPs || []).some((o) => o === userOrg);
    if (!isAllowed) {
        const message = `Members of organization ${userOrg} do not have sufficient permissions.`;
        const user = ctx === null || ctx === void 0 ? void 0 : ctx.callingUser;
        throw new OrganizationNotAllowedError(message, { user, userOrg });
    }
}
exports.ensureOrganizationIsAllowed = ensureOrganizationIsAllowed;
function recoverPublicKey(signature, dto) {
    try {
        return api_1.signatures.recoverPublicKey(signature, dto);
    }
    catch (err) {
        return undefined;
    }
}
async function getSavedPKOrReject(ctx, userId) {
    const publicKey = await services_1.PublicKeyService.getPublicKey(ctx, userId);
    if (publicKey === undefined) {
        throw new UserNotRegisteredError(userId);
    }
    return publicKey;
}
