"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.constructVerifiedMints = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const class_transformer_1 = require("class-transformer");
const balances_1 = require("../balances");
async function constructVerifiedMints(ctx, dto, tokenClass, instanceCounter) {
    var _a;
    const callingUser = ctx.callingUser;
    const owner = (_a = dto.owner) !== null && _a !== void 0 ? _a : callingUser;
    const { collection, category, type, additionalKey } = dto;
    const tokenClassKey = await api_1.TokenClass.buildClassKeyObject({ collection, category, type, additionalKey });
    const quantity = dto.quantity;
    if (tokenClass.isNonFungible) {
        if (quantity.isGreaterThan(api_1.MintTokenDto.MAX_NFT_MINT_SIZE)) {
            throw new Error(`You can mint only ${api_1.MintTokenDto.MAX_NFT_MINT_SIZE} NFTs (quantity provided: ${quantity}).`);
        }
        if (callingUser !== dto.owner && !tokenClass.authorities.includes(callingUser)) {
            throw new Error(`NFTs can only be minted by token authorities, or with ones own mint allowance. ` +
                `callingUser: ${callingUser}; dto.owner: ${dto.owner}, ` +
                `authorities: ${tokenClass.authorities.join(", ")}`);
        }
        const userBalance = await (0, balances_1.fetchOrCreateBalance)(ctx, owner, tokenClassKey);
        const instanceIds = [];
        const mintedNFTs = [];
        for (let i = 0; i < quantity.toNumber(); i += 1) {
            instanceCounter = instanceCounter.plus("1");
            const mintInstance = new bignumber_js_1.default(instanceCounter);
            const nftInfo = (0, class_transformer_1.plainToInstance)(api_1.TokenInstance, {
                collection,
                category,
                type,
                additionalKey,
                instance: mintInstance,
                owner,
                isNonFungible: true
            });
            instanceIds.push(nftInfo.instance);
            mintedNFTs.push(nftInfo);
        }
        instanceIds.forEach((instanceId) => {
            userBalance.ensureCanAddInstance(instanceId).add();
        });
        return [mintedNFTs, userBalance];
    }
    else {
        const userBalance = await (0, balances_1.fetchOrCreateBalance)(ctx, owner, tokenClassKey);
        userBalance.ensureCanAddQuantity(quantity).add();
        const fungibleReturnInstance = (0, class_transformer_1.plainToInstance)(api_1.TokenInstance, {
            collection,
            category,
            type,
            additionalKey,
            instance: api_1.TokenInstance.FUNGIBLE_TOKEN_INSTANCE,
            owner,
            isNonFungible: false
        });
        return [[fungibleReturnInstance], userBalance];
    }
}
exports.constructVerifiedMints = constructVerifiedMints;
