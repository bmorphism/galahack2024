"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.indexMintOperations = exports.batchMintToken = void 0;
const tslib_1 = require("tslib");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const allowances_1 = require("../allowances");
const MintError_1 = require("./MintError");
const fetchMintSupply_1 = require("./fetchMintSupply");
const mintToken_1 = require("./mintToken");
async function batchMintToken(ctx, ops) {
    var _a;
    const minted = [];
    const errors = [];
    const opsByTokenClass = indexMintOperations(ctx, ops);
    for (const indexKey in opsByTokenClass) {
        const opsByToken = opsByTokenClass[indexKey];
        const tokenClassKey = opsByToken.tokenClassKey;
        let knownTotalSupply = await (0, fetchMintSupply_1.fetchMintSupply)(ctx, tokenClassKey);
        for (const indexKeyByCaller in opsByToken.mintOperationsIndex) {
            const tokenOpsByCaller = opsByToken.mintOperationsIndex[indexKeyByCaller];
            const callingOnBehalf = tokenOpsByCaller.callingOnBehalf;
            // Get allowances
            const fetchAllowancesData = {
                grantedTo: `${callingOnBehalf}`,
                collection: tokenClassKey.collection,
                category: tokenClassKey.category,
                type: tokenClassKey.type,
                additionalKey: tokenClassKey.additionalKey
            };
            const applicableAllowances = await (0, allowances_1.fetchAllowances)(ctx, fetchAllowancesData);
            const mintOpsBatch = tokenOpsByCaller.mintOperations;
            // mints sequentially; fails all mints if at least one operation fails
            for (let i = 0; i < mintOpsBatch.length; i += 1) {
                const mintOp = mintOpsBatch[i];
                mintOp.knownTotalSupply = new bignumber_js_1.default(knownTotalSupply);
                mintOp.applicableAllowances = applicableAllowances;
                try {
                    const mintResponse = await (0, mintToken_1.mintToken)(ctx, mintOp);
                    minted.push(...mintResponse);
                }
                catch (e) {
                    errors.push(`index: ${i}, message: ${(_a = e.message) !== null && _a !== void 0 ? _a : ""}`);
                }
                // ensure we're incrementing known supply as we go
                knownTotalSupply = knownTotalSupply.plus(mintOp.quantity);
            }
        }
    }
    if (errors.length > 0) {
        throw new MintError_1.BatchMintError(errors);
    }
    else {
        return minted;
    }
}
exports.batchMintToken = batchMintToken;
function indexMintOperations(ctx, ops) {
    var _a, _b;
    const mintIndex = {};
    for (let i = 0; i < ops.length; i++) {
        const callingOnBehalf = (_a = ops[i].authorizedOnBehalf) !== null && _a !== void 0 ? _a : ctx.callingUser;
        const { collection, category, type, additionalKey } = ops[i].tokenClassKey;
        const tokenKey = `${collection}_${category}_${type}_${additionalKey}`;
        if (mintIndex[tokenKey] === undefined) {
            const emptyIndexedTokenClass = {
                tokenClassKey: ops[i].tokenClassKey,
                mintOperationsIndex: {}
            };
            mintIndex[tokenKey] = emptyIndexedTokenClass;
        }
        const key = `${callingOnBehalf}_${collection}_${category}_${type}_${additionalKey}`;
        if (mintIndex[tokenKey].mintOperationsIndex[key] === undefined) {
            const emptyIndexedMintOp = {
                callingOnBehalf: (_b = ops[i].authorizedOnBehalf) !== null && _b !== void 0 ? _b : ctx.callingUser,
                mintOperations: []
            };
            mintIndex[tokenKey].mintOperationsIndex[key] = emptyIndexedMintOp;
        }
        mintIndex[tokenKey].mintOperationsIndex[key].mintOperations.push(ops[i]);
    }
    return mintIndex;
}
exports.indexMintOperations = indexMintOperations;
