"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchMintAllowanceSupplyForToken = exports.fetchMintAllowanceSupply = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const class_transformer_1 = require("class-transformer");
const utils_1 = require("../utils");
async function fetchMintAllowanceSupply(ctx, tokenClass, offsetCurrentTimeMs) {
    // The block timeout times 2 is the default offset, rather than zero, because querying requests from
    // the current time could cause concurrent minting to fail with MVCC_READ_CONFLICTs.
    // Consumers must explicitly override this with a 0 value to read with no offset.
    const startTimeOffset = offsetCurrentTimeMs !== null && offsetCurrentTimeMs !== void 0 ? offsetCurrentTimeMs : utils_1.lookbackTimeOffset;
    const startTimeKey = (0, utils_1.inverseTime)(ctx, startTimeOffset);
    const keyLen = utils_1.inverseKeyLength;
    const startKey = [
        api_1.TokenMintAllowanceRequest.INDEX_KEY,
        tokenClass.collection,
        tokenClass.category,
        tokenClass.type,
        tokenClass.additionalKey,
        startTimeKey,
        "".padStart(keyLen, "0")
    ].join(api_1.ChainObject.MIN_UNICODE_RUNE_VALUE);
    const endKey = [
        api_1.TokenMintAllowanceRequest.INDEX_KEY,
        tokenClass.collection,
        tokenClass.category,
        tokenClass.type,
        tokenClass.additionalKey,
        "".padStart(keyLen, "z"),
        "".padStart(keyLen, "z")
    ].join(api_1.ChainObject.MIN_UNICODE_RUNE_VALUE);
    const iterator = ctx.stub.getStateByRange(startKey, endKey);
    let seekingFirstResult = true;
    let resultsCount = 0;
    const minResults = utils_1.lookbackTxCount;
    const previousRequests = [];
    try {
        for await (const kv of iterator) {
            if (!seekingFirstResult && resultsCount >= minResults) {
                break;
            }
            if (kv.value) {
                const stringResult = Buffer.from(kv.value).toString("utf8");
                const entry = api_1.RangedChainObject.deserialize(api_1.TokenMintAllowanceRequest, stringResult);
                // timeKey is a string padded with leading zeros. BigNumber.js will parse this format into an integer.
                const entryTime = new bignumber_js_1.default(entry.timeKey);
                seekingFirstResult = false;
                resultsCount++;
                // inverted timeKeys read most recent first; using unshift sorts a new array as oldest first.
                // essentially, we rewind the tape and then play it forward.
                // covering the following possible scensarios:
                //     a) no results yet - empty array, start with zero below.
                //     b) no recent results. continue back toward the beginning of the ledger until we find at least one.
                //     c) recent results. Get all results within two past block spans to cover any missing timestamp gaps from concurrent recent transactions.
                previousRequests.unshift(entry);
            }
        }
    }
    catch (e) {
        throw new Error(`Failed to get iterator for getStateByRange with key: ${startKey}, ${iterator}, ${e}`);
    }
    let startingKnownMintAllowancesCount = new bignumber_js_1.default("0");
    let updatedKnownMintAllowancesCount = new bignumber_js_1.default("0");
    let firstResult = true;
    for (const entry of previousRequests) {
        if (firstResult && entry.totalKnownMintAllowancesCount.isGreaterThan(startingKnownMintAllowancesCount)) {
            // establish base line for first result
            startingKnownMintAllowancesCount = entry.totalKnownMintAllowancesCount;
            updatedKnownMintAllowancesCount = new bignumber_js_1.default(entry.totalKnownMintAllowancesCount);
        }
        firstResult = false;
        updatedKnownMintAllowancesCount = updatedKnownMintAllowancesCount.plus(entry.quantity);
    }
    return updatedKnownMintAllowancesCount;
}
exports.fetchMintAllowanceSupply = fetchMintAllowanceSupply;
async function fetchMintAllowanceSupplyForToken(ctx, data) {
    const { collection, category, type, additionalKey } = data;
    const keyList = [collection, category, type, additionalKey];
    const compositeKey = api_1.ChainObject.getCompositeKeyFromParts(api_1.TokenClass.INDEX_KEY, keyList);
    const tokenClass = await (0, utils_1.getObjectByKey)(ctx, api_1.TokenClass, compositeKey);
    const supply = await fetchMintAllowanceSupply(ctx, tokenClass);
    const response = (0, class_transformer_1.plainToInstance)(api_1.FetchTokenSupplyResponse, {
        supply
    });
    return response;
}
exports.fetchMintAllowanceSupplyForToken = fetchMintAllowanceSupplyForToken;
