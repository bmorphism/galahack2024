"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestMintAllowance = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const allowances_1 = require("../allowances");
const grantAllowance_1 = require("../allowances/grantAllowance");
const fetchBurns_1 = require("../burns/fetchBurns");
const utils_1 = require("../utils");
const fetchMintAllowanceSupply_1 = require("./fetchMintAllowanceSupply");
async function requestMintAllowance(ctx, dto) {
    var _a;
    if (dto.allowanceType !== api_1.AllowanceType.Mint) {
        throw new Error(`SubmitMintAllowanceRequest only supports AllowanceType.Mint transactions. Provided: ${dto.allowanceType}`);
    }
    if (new Set(dto.quantities.map((i) => i.user)).size !== dto.quantities.length) {
        const message = "dto.quantities must contain a unique set of users. Users cannot be duplicated in a single GrantAllowance call";
        throw new Error(message);
    }
    // todo: rework this with a correct dto that specs instance key insead of query key
    if (!dto.tokenInstance.isCompleteKey()) {
        throw new Error(`SubmitMintAllowanceRequest requires a complete token key.`);
    }
    const instanceKey = dto.tokenInstance.toCompleteKey();
    const tokenInstanceKeyString = api_1.TokenInstance.CreateCompositeKey(instanceKey);
    const callingUser = ctx.callingUser;
    const totalQuantity = dto.quantities.reduce((a, b) => a.plus(b.quantity), new bignumber_js_1.default(0));
    // This will throw an error if it can't be found
    const keyList = api_1.TokenClass.buildClassKeyList(instanceKey);
    const compositeKey = api_1.ChainObject.getCompositeKeyFromParts(api_1.TokenClass.INDEX_KEY, keyList);
    const tokenClass = await (0, utils_1.getObjectByKey)(ctx, api_1.TokenClass, compositeKey);
    // Only token authorities can grant mint allowances
    if (!tokenClass.authorities.includes(callingUser)) {
        throw new Error(`User ${callingUser} is not an authority on token ${tokenInstanceKeyString} and may not create minting allowances.\nToken Authorities: ${tokenClass.authorities.join(",")}`);
    }
    if (tokenClass.isNonFungible && !instanceKey.instance.isEqualTo(0)) {
        throw new Error(`Mint Allowance attempted for NFT with non-zero instance id (${instanceKey.instance}).
                      NFT Mint Allowances require an instance property of 0.`);
    }
    const knownMintAllowanceSupply = await (0, fetchMintAllowanceSupply_1.fetchMintAllowanceSupply)(ctx, tokenClass);
    const knownBurnsCount = await (0, fetchBurns_1.fetchKnownBurnCount)(ctx, tokenClass);
    // throws if quantity exceeds supply or capacity
    (0, allowances_1.ensureQuantityCanBeMinted)(tokenClass, totalQuantity, knownMintAllowanceSupply, knownBurnsCount);
    const { allowanceType, quantities, uses } = dto;
    const expires = (_a = dto.expires) !== null && _a !== void 0 ? _a : 0;
    const success = await (0, grantAllowance_1.putMintAllowanceRequestsOnChain)(ctx, { allowanceType, quantities, uses, expires }, tokenClass, knownMintAllowanceSupply);
    const successfulRequests = success.map((elem) => {
        var _a;
        const trimmedMintRequest = new api_1.MintRequestDto();
        trimmedMintRequest.collection = elem.collection;
        trimmedMintRequest.category = elem.category;
        trimmedMintRequest.type = elem.type;
        trimmedMintRequest.additionalKey = elem.additionalKey;
        trimmedMintRequest.timeKey = elem.timeKey;
        trimmedMintRequest.totalKnownMintsCount = elem.totalKnownMintAllowancesCount;
        trimmedMintRequest.id = elem.id;
        trimmedMintRequest.owner = (_a = elem.grantedTo) !== null && _a !== void 0 ? _a : undefined;
        return trimmedMintRequest;
    });
    const res = new api_1.FulfillMintAllowanceDto();
    res.requests = successfulRequests;
    return res;
}
exports.requestMintAllowance = requestMintAllowance;
