"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateTotalSupply = exports.mintToken = void 0;
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const api_2 = require("@gala-chain/api");
const bignumber_js_1 = require("bignumber.js");
const allowances_1 = require("../allowances");
const balances_1 = require("../balances");
const TokenError_1 = require("../token/TokenError");
const utils_1 = require("../utils");
const MintError_1 = require("./MintError");
const requestMint_1 = require("./requestMint");
async function mintToken(ctx, { tokenClassKey, owner, quantity, authorizedOnBehalf, applicableAllowanceKey, applicableAllowances, knownTotalSupply }) {
    var _a, _b;
    const callingOnBehalf = (_a = authorizedOnBehalf === null || authorizedOnBehalf === void 0 ? void 0 : authorizedOnBehalf.callingOnBehalf) !== null && _a !== void 0 ? _a : ctx.callingUser;
    // This will throw an error if it can't be found
    const tokenClass = await (0, utils_1.getObjectByKey)(ctx, api_1.TokenClass, api_1.TokenClass.getCompositeKeyFromParts(api_1.TokenClass.INDEX_KEY, api_1.TokenClass.buildClassKeyList(tokenClassKey)));
    const decimalPlaces = (_b = quantity.decimalPlaces()) !== null && _b !== void 0 ? _b : 0;
    if (decimalPlaces > tokenClass.decimals) {
        throw new TokenError_1.InvalidDecimalError(quantity, tokenClass.decimals);
    }
    // dto is valid, do chain code specific validation
    let applicableAllowanceResponse = [];
    if (applicableAllowanceKey) {
        const allowance = await (0, utils_1.getObjectByKey)(ctx, api_1.TokenAllowance, api_2.ChainObject.getCompositeKeyFromParts(api_1.TokenAllowance.INDEX_KEY, [
            applicableAllowanceKey.grantedTo,
            applicableAllowanceKey.collection,
            applicableAllowanceKey.category,
            applicableAllowanceKey.type,
            applicableAllowanceKey.additionalKey,
            applicableAllowanceKey.instance.toString(),
            applicableAllowanceKey.allowanceType.toString(),
            applicableAllowanceKey.grantedBy,
            applicableAllowanceKey.created.toString()
        ]));
        applicableAllowanceResponse = [allowance];
    }
    else if (Array.isArray(applicableAllowances) && applicableAllowances.length > 0) {
        applicableAllowanceResponse = applicableAllowances;
    }
    else {
        // Get allowances
        const fetchAllowancesData = {
            grantedTo: callingOnBehalf,
            collection: tokenClassKey.collection,
            category: tokenClassKey.category,
            type: tokenClassKey.type,
            additionalKey: tokenClassKey.additionalKey
        };
        applicableAllowanceResponse = await (0, allowances_1.fetchAllowances)(ctx, fetchAllowancesData);
    }
    const dtoInstanceKey = api_2.ChainCallDTO.deserialize(api_1.TokenInstanceKey, {
        ...tokenClassKey,
        instance: api_1.TokenInstance.FUNGIBLE_TOKEN_INSTANCE
    });
    // Check allowances
    const totalAllowance = await (0, allowances_1.checkAllowances)(ctx, applicableAllowanceResponse, dtoInstanceKey, api_1.AllowanceType.Mint, callingOnBehalf);
    if (totalAllowance.isLessThan(quantity)) {
        throw new MintError_1.InsufficientMintAllowanceError(callingOnBehalf, totalAllowance, quantity, dtoInstanceKey, owner);
    }
    // check that mint is valid based on max supply, max capacity, etc
    (0, allowances_1.ensureQuantityCanBeMinted)(tokenClass, quantity);
    // if possible, spend allowances
    const allowancesUsed = await (0, allowances_1.useAllowances)(ctx, new bignumber_js_1.BigNumber(quantity), applicableAllowanceResponse);
    if (!allowancesUsed) {
        throw new MintError_1.UseAllowancesFailedError(quantity, dtoInstanceKey.toStringKey(), owner);
    }
    if (tokenClass.isNonFungible) {
        // For NFTs we have an upper limit
        if (quantity.isGreaterThan(api_1.MintTokenDto.MAX_NFT_MINT_SIZE)) {
            throw new MintError_1.NftMaxMintError(quantity);
        }
        /*
         * GalaChainTokenAllowances contain an instance property.
         * for fungible tokens, the instance property on the minted token is less important.
         * for NFTs, the Allowance instance should be the generic 0 instance value.
         * And the newly minted NFT token should be a unique, 1-indexed value.
         */
        const userBalance = await (0, balances_1.fetchOrCreateBalance)(ctx, owner, await api_1.TokenClass.buildClassKeyObject(tokenClassKey));
        const mintedNFTs = [];
        // Max supply and max capacity are checking when giving allowances
        // so we are not checking it here when we are using allowances to
        // create new tokens
        for (let i = 0; i < quantity.toNumber(); i += 1) {
            // Update Token Class Total Supply
            tokenClass.totalSupply = tokenClass.totalSupply.plus(1);
            // Create Instance of token
            const nftInfo = new api_1.TokenInstance();
            nftInfo.owner = owner;
            nftInfo.collection = tokenClassKey.collection;
            nftInfo.category = tokenClassKey.category;
            nftInfo.type = tokenClassKey.type;
            nftInfo.additionalKey = tokenClassKey.additionalKey;
            nftInfo.instance = tokenClass.totalSupply;
            nftInfo.isNonFungible = true;
            mintedNFTs.push(nftInfo);
            // update balance
            userBalance.ensureCanAddInstance(nftInfo.instance).add();
        }
        // save instances
        await Promise.all(mintedNFTs.map((nft) => (0, utils_1.putChainObject)(ctx, nft)));
        await (0, utils_1.putChainObject)(ctx, userBalance);
        await (0, utils_1.putChainObject)(ctx, tokenClass);
        const returnKeys = [];
        for (const nftInfo of mintedNFTs) {
            returnKeys.push(await api_1.TokenInstance.buildInstanceKeyObject(nftInfo));
        }
        await updateTotalSupply(ctx, {
            tokenClassKey,
            callingUser: callingOnBehalf,
            owner,
            quantity,
            allowanceKey: applicableAllowanceKey,
            knownTotalSupply: knownTotalSupply
        });
        return returnKeys;
    }
    else {
        // Update the balance of the target user, or create it.
        const userBalance = await (0, balances_1.fetchOrCreateBalance)(ctx, owner, tokenClassKey);
        userBalance.ensureCanAddQuantity(quantity).add();
        // Write the balance to the chain
        await (0, utils_1.putChainObject)(ctx, userBalance);
        tokenClass.totalSupply = tokenClass.totalSupply.plus(quantity);
        await (0, utils_1.putChainObject)(ctx, tokenClass);
        await updateTotalSupply(ctx, {
            tokenClassKey,
            callingUser: callingOnBehalf,
            owner,
            quantity,
            allowanceKey: applicableAllowanceKey,
            knownTotalSupply
        });
        return [dtoInstanceKey];
    }
}
exports.mintToken = mintToken;
// for backwards-compatibility with high throughput total supply data structures
async function updateTotalSupply(ctx, { tokenClassKey, callingUser, owner, quantity, allowanceKey, knownTotalSupply }) {
    const mintRequest = await (0, requestMint_1.writeMintRequest)(ctx, {
        tokenClassKey,
        callingUser,
        owner,
        quantity,
        allowanceKey,
        knownTotalSupply
    });
    const mintFulfillmentEntry = mintRequest.fulfill(quantity);
    await (0, utils_1.putChainObject)(ctx, mintFulfillmentEntry);
}
exports.updateTotalSupply = updateTotalSupply;
