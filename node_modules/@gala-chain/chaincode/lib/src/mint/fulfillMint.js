"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fulfillMintRequest = exports.mintRequestsByTimeKeys = exports.mintRequestsByTimeRange = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const api_2 = require("@gala-chain/api");
const api_3 = require("@gala-chain/api");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const class_transformer_1 = require("class-transformer");
const util_1 = require("util");
const allowances_1 = require("../allowances");
const fetchBurns_1 = require("../burns/fetchBurns");
const utils_1 = require("../utils");
const utils_2 = require("../utils");
const constructVerifiedMints_1 = require("./constructVerifiedMints");
const indexMintRequests_1 = require("./indexMintRequests");
const validateMintRequest_1 = require("./validateMintRequest");
async function mintRequestsByTimeRange(ctx, tokenClass, startTimestamp, endTimestamp) {
    // assuming start/end timestamps are more intuitive for a client constructing a dto,
    // we redefine here in code as recent / oldest to work with our inverted index:
    // In our leveldb table, start keys are generated from the more recent timestamps, and end keys are the oldest,
    // effectively the reverse of the dto property defintions.
    const mostRecentTime = endTimestamp !== null && endTimestamp !== void 0 ? endTimestamp : ctx.txUnixTime - utils_2.blockTimeout;
    const oldestTime = startTimestamp !== null && startTimestamp !== void 0 ? startTimestamp : 0;
    const recentTimeKey = (0, utils_2.generateInverseTimeKey)(mostRecentTime);
    const oldestTimeKey = (0, utils_2.generateInverseTimeKey)(oldestTime);
    const requestEntries = await mintRequestsByTimeKeys(ctx, tokenClass, recentTimeKey, oldestTimeKey);
    return requestEntries;
}
exports.mintRequestsByTimeRange = mintRequestsByTimeRange;
async function mintRequestsByTimeKeys(ctx, tokenClass, recentTimeKey, oldestTimeKey) {
    var _a;
    const startKey = [
        api_1.TokenMintRequest.INDEX_KEY,
        tokenClass.collection,
        tokenClass.category,
        tokenClass.type,
        tokenClass.additionalKey,
        recentTimeKey,
        "".padStart(utils_2.inverseKeyLength, "0")
    ].join(api_2.ChainObject.MIN_UNICODE_RUNE_VALUE);
    const endKey = [
        api_1.TokenMintRequest.INDEX_KEY,
        tokenClass.collection,
        tokenClass.category,
        tokenClass.type,
        tokenClass.additionalKey,
        oldestTimeKey,
        "".padStart(utils_2.inverseKeyLength, "z")
    ].join(api_2.ChainObject.MIN_UNICODE_RUNE_VALUE);
    const iterator = ctx.stub.getStateByRange(startKey, endKey);
    const requestEntries = [];
    try {
        for await (const kv of iterator) {
            if (kv.value) {
                const stringResult = Buffer.from(kv.value).toString("utf8");
                const entry = api_1.TokenMintRequest.deserialize(api_1.TokenMintRequest, stringResult);
                // Inverted time keys order our entries most recent first in the LevelDB key space.
                // By using unshift(), we are filling our working array with the oldest results first,
                // in order to iterate minting/fulfillment in the order received.
                requestEntries.unshift(entry);
            }
        }
    }
    catch (e) {
        throw new api_2.RuntimeError(`Error encountered while processing ctx.stub.getStateByRange Async Iterator for ` +
            `startKey ${startKey}, endKey ${endKey}: ${(_a = e === null || e === void 0 ? void 0 : e.message) !== null && _a !== void 0 ? _a : e}`);
    }
    return requestEntries;
}
exports.mintRequestsByTimeKeys = mintRequestsByTimeKeys;
async function fulfillMintRequest(ctx, dto) {
    var _a;
    const requests = dto.requests;
    const requestIds = requests.map((r) => r.id);
    const reqIdx = (0, indexMintRequests_1.indexMintRequests)(requests);
    let resultInstanceKeys = [];
    const successful = [];
    // todo: type this failures array and work it into response
    const failures = [];
    for (const [, values] of Object.entries(reqIdx)) {
        // Entries in the Request Index represent
        // some number of mint requests for the same token, at the same running total height.
        // Because our original GrantAllowance implementation allowed (potentially large) arrays,
        // especially used for granting allowances for fungible tokens, we maintain that support here.
        // The tradeoff in supporting this backwards compatibility comes at the cost of greater complexity.
        //
        // *Warning*: while this code could technically support the following input scenarios, the combined transaction
        // would most likely be too expensive in terms of compute resources and/or timeout if a request comes in for
        //     a) multiple different tokens
        //     b) MintRequests generated from various blocks with differing running totals
        // indexMintRequests() ensures every value indexed will have equivalent values for these
        // five properties and that at least one value will exist.
        const { collection, category, type, additionalKey, totalKnownMintsCount } = values[0];
        const tokenKey = api_2.ChainObject.getCompositeKeyFromParts(api_1.TokenClass.INDEX_KEY, [
            collection,
            category,
            type,
            additionalKey
        ]);
        const tokenClass = await (0, utils_1.getObjectByKey)(ctx, api_1.TokenClass, tokenKey);
        const tokenClassKey = await api_1.TokenClass.buildClassKeyObject({
            collection,
            category,
            type,
            additionalKey
        });
        const dtoInstanceKey = api_2.ChainCallDTO.deserialize(api_1.TokenInstanceKey, {
            ...tokenClassKey,
            instance: api_1.TokenInstance.FUNGIBLE_TOKEN_INSTANCE
        });
        let mostRecentTimeInversion = new bignumber_js_1.default(utils_2.inversionHeight), oldestTimeInversion = new bignumber_js_1.default("0");
        for (const req of values) {
            // timeKeys are inverted timestamps, lowest = most recent, highest = oldest
            const reqTime = new bignumber_js_1.default(req.timeKey);
            if (reqTime.isLessThan(mostRecentTimeInversion)) {
                mostRecentTimeInversion = reqTime;
            }
            // no else/if here. we check for both, to prevent a single result causing an unbounded range query.
            if (reqTime.isGreaterThan(oldestTimeInversion)) {
                oldestTimeInversion = reqTime;
            }
        }
        // working with an inverted time, adding to the inverted timestamp makes it older, not newer
        oldestTimeInversion = oldestTimeInversion.plus(utils_2.lookbackTimeOffset);
        const recentTimeKey = mostRecentTimeInversion.toString().padStart(utils_2.inverseKeyLength, "0");
        const oldestTimeKey = oldestTimeInversion.toString().padStart(utils_2.inverseKeyLength, "0");
        const requestEntries = await mintRequestsByTimeKeys(ctx, tokenClassKey, recentTimeKey, oldestTimeKey);
        if (requestEntries.length < 1) {
            const recentTimeKey = mostRecentTimeInversion.toString().padStart(utils_2.inverseKeyLength, "0");
            const oldestTimeKey = oldestTimeInversion.toString().padStart(utils_2.inverseKeyLength, "0");
            throw api_2.GalaChainResponse.Error(new Error(`FulfillMint failure: No TokenMintRequest(s) found on chain. ` +
                `${(0, util_1.inspect)(tokenClass, {
                    depth: 4,
                    breakLength: Infinity,
                    compact: true
                })}, startKey: ${recentTimeKey}, endKey: ${oldestTimeKey}`));
        }
        let runningQuantityCheckTotal = new bignumber_js_1.default(totalKnownMintsCount);
        let instanceCounter = new bignumber_js_1.default(totalKnownMintsCount);
        // check mintable qty here, supply and capacity, then process scenarios:
        // a) grant all allowances, nothing is exceeded by total
        // b) threshold block; some amount of requests are within limits, some not
        // c) threshold exceeded; token is maxed out and none of these requests go through
        //    it should be unlikely that c) could occur,
        //    because most likely RequestMint contract method have already been denied.
        for (let i = 0; i < requestEntries.length; i++) {
            const req = requestEntries[i];
            if (!requestIds.includes(req.id)) {
                runningQuantityCheckTotal = runningQuantityCheckTotal.plus(req.quantity);
                instanceCounter = instanceCounter.plus(req.quantity);
                continue;
            }
            let mintableQty = false;
            let qtyError;
            try {
                const knownBurnsCount = await (0, fetchBurns_1.fetchKnownBurnCount)(ctx, tokenClass);
                mintableQty = (0, allowances_1.ensureQuantityCanBeMinted)(tokenClass, req.quantity, runningQuantityCheckTotal, knownBurnsCount);
            }
            catch (e) {
                qtyError = e;
            }
            runningQuantityCheckTotal = runningQuantityCheckTotal.plus(req.quantity);
            // todo: get back remainder from CheckMintableQuantity (now renamed ensureQuantityCanBeMinted),
            // and handle PartiallyMinted request states
            // i.e. I requested to mint 5, but only two were left.
            if (!mintableQty) {
                failures.push({ message: qtyError === null || qtyError === void 0 ? void 0 : qtyError.message, data: { qty: mintableQty, req: req } });
            }
            else {
                const mintFulfillmentEntry = req.fulfill(req.quantity);
                const mintDto = (0, class_transformer_1.plainToInstance)(api_3.MintTokenDto, {
                    tokenClass: { collection, category, type, additionalKey },
                    owner: req.owner,
                    quantity: req.quantity,
                    allowanceKey: req.allowanceKey
                });
                // todo: bridging support. refactor FulfillMint and/or validateMintRequest
                // functionality to replace the hard-coded `undefined`
                // below with bridgeUserType handling.
                const applicableAllowances = await (0, validateMintRequest_1.validateMintRequest)(ctx, mintDto, tokenClass, undefined);
                const actionDescription = `${api_1.AllowanceType.Mint} ${req.quantity.toString()} ` +
                    `token ${dtoInstanceKey.toStringKey()} to ${req.owner}`;
                const allowancesUsed = await (0, allowances_1.useAllowances)(ctx, new bignumber_js_1.default(req.quantity), applicableAllowances);
                if (!allowancesUsed) {
                    failures.push({
                        req: req,
                        allowancesUsed: allowancesUsed,
                        message: `Failed to use allowances to ${actionDescription}`
                    });
                    continue;
                }
                try {
                    const [instances, balance] = await (0, constructVerifiedMints_1.constructVerifiedMints)(ctx, mintFulfillmentEntry, tokenClass, instanceCounter);
                    const returnKeys = [];
                    for (const instance of instances) {
                        if (tokenClass.isNonFungible) {
                            await (0, utils_1.putChainObject)(ctx, instance);
                        }
                        returnKeys.push(await api_1.TokenInstance.buildInstanceKeyObject(instance));
                    }
                    await (0, utils_1.putChainObject)(ctx, balance);
                    resultInstanceKeys = resultInstanceKeys.concat(returnKeys);
                }
                catch (e) {
                    failures.push({
                        req: req,
                        message: (_a = e === null || e === void 0 ? void 0 : e.message) !== null && _a !== void 0 ? _a : "ConstructVerifiedMints failed"
                    });
                    continue;
                }
                successful.push(mintFulfillmentEntry);
            }
        }
    }
    await Promise.all(successful.map((mintFulfillment) => (0, utils_1.putChainObject)(ctx, mintFulfillment)));
    if (resultInstanceKeys.length < dto.requests.length) {
        throw new Error(JSON.stringify({
            success: resultInstanceKeys,
            errors: failures
        }));
    }
    return resultInstanceKeys;
}
exports.fulfillMintRequest = fulfillMintRequest;
