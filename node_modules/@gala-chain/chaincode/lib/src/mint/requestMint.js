"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeMintRequest = exports.submitMintRequest = exports.requestMintBatch = exports.requestMint = void 0;
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const class_transformer_1 = require("class-transformer");
const utils_1 = require("../utils");
const fetchMintSupply_1 = require("./fetchMintSupply");
const validateMintRequest_1 = require("./validateMintRequest");
async function requestMint(ctx, dto, authorizedOnBehalf) {
    const mintRequest = await submitMintRequest(ctx, dto, authorizedOnBehalf);
    // simplified object for data transfer over the wire
    const mintRequestDto = new api_1.MintRequestDto();
    mintRequestDto.collection = mintRequest.collection;
    mintRequestDto.category = mintRequest.category;
    mintRequestDto.type = mintRequest.type;
    mintRequestDto.additionalKey = mintRequest.additionalKey;
    mintRequestDto.timeKey = mintRequest.timeKey;
    mintRequestDto.totalKnownMintsCount = mintRequest.totalKnownMintsCount;
    mintRequestDto.owner = mintRequest.owner;
    mintRequestDto.id = mintRequest.requestId();
    mintRequestDto.allowanceKey = dto.allowanceKey;
    const resDto = new api_1.FulfillMintDto();
    resDto.requests = [mintRequestDto];
    return resDto;
}
exports.requestMint = requestMint;
async function requestMintBatch(ctx, dto, authorizedOnBehalf) {
    var _a;
    const minted = [];
    const errors = [];
    // mints sequentially; fails all mints if at least one operation fails
    for (let i = 0; i < dto.mintDtos.length; i += 1) {
        const mintDto = dto.mintDtos[i];
        try {
            const mintRequest = await submitMintRequest(ctx, mintDto, authorizedOnBehalf);
            const mintRequestDto = (0, class_transformer_1.plainToInstance)(api_1.MintRequestDto, mintRequest);
            mintRequestDto.allowanceKey = mintDto.allowanceKey;
            minted.push(mintRequestDto);
        }
        catch (e) {
            errors.push(`index: ${i}, message: ${(_a = e.message) !== null && _a !== void 0 ? _a : ""}`);
        }
    }
    if (errors.length > 0) {
        throw new Error(`No token was minted. Errors: ${errors.join("; ")}.`);
    }
    else {
        const resDto = (0, class_transformer_1.plainToInstance)(api_1.FulfillMintDto, {
            requests: minted
        });
        return resDto;
    }
}
exports.requestMintBatch = requestMintBatch;
async function submitMintRequest(ctx, dto, authorizedOnBehalf) {
    var _a;
    if (!dto)
        throw new Error("dto undefined");
    const callingUser = ctx.callingUser;
    const owner = (_a = dto.owner) !== null && _a !== void 0 ? _a : callingUser;
    const tokenClassKey = dto.tokenClass;
    const quantity = dto.quantity;
    const allowanceKey = dto.allowanceKey;
    const tokenClass = await (0, utils_1.getObjectByKey)(ctx, api_1.TokenClass, api_1.TokenClass.getCompositeKeyFromParts(api_1.TokenClass.INDEX_KEY, api_1.TokenClass.buildClassKeyList(tokenClassKey)));
    if (!tokenClass)
        throw new Error("missing tokenclass");
    await (0, validateMintRequest_1.validateMintRequest)(ctx, dto, tokenClass, authorizedOnBehalf).catch((e) => {
        throw new Error(`ValidateMintRequest failure: ${e.message}`);
    });
    const mintRequest = await writeMintRequest(ctx, {
        tokenClassKey,
        callingUser,
        owner,
        quantity,
        allowanceKey
    });
    return mintRequest;
}
exports.submitMintRequest = submitMintRequest;
async function writeMintRequest(ctx, { tokenClassKey, callingUser, owner, quantity, allowanceKey, knownTotalSupply }) {
    // for batch operations, support a way to pass in the knownTotalSupply to avoid repeated range queries
    // knownTotalSupply should never be exposed in a dto,
    // it should only ever be determined by application code logic.
    let totalKnownMintsCount;
    if (knownTotalSupply === undefined) {
        totalKnownMintsCount = await (0, fetchMintSupply_1.fetchMintSupply)(ctx, tokenClassKey).catch((e) => {
            throw new Error(`fetchMintSupply failure: ${e.message}`);
        });
    }
    else {
        totalKnownMintsCount = knownTotalSupply;
    }
    const epochKey = (0, utils_1.inverseEpoch)(ctx, 0);
    const timeKey = (0, utils_1.inverseTime)(ctx, 0);
    const mintRequest = new api_1.TokenMintRequest();
    mintRequest.collection = tokenClassKey.collection;
    mintRequest.category = tokenClassKey.category;
    mintRequest.type = tokenClassKey.type;
    mintRequest.additionalKey = tokenClassKey.additionalKey;
    mintRequest.timeKey = timeKey;
    mintRequest.totalKnownMintsCount = totalKnownMintsCount;
    mintRequest.requestor = callingUser;
    mintRequest.owner = owner;
    mintRequest.created = ctx.txUnixTime;
    mintRequest.quantity = quantity;
    mintRequest.state = api_1.TokenMintStatus.Unknown;
    mintRequest.id = mintRequest.requestId();
    mintRequest.created = ctx.txUnixTime;
    mintRequest.epoch = epochKey;
    mintRequest.allowanceKey = allowanceKey;
    await (0, utils_1.putRangedChainObject)(ctx, mintRequest).catch((e) => {
        throw new Error(`MintRequest putState failure: ${e.message}`);
    });
    return mintRequest;
}
exports.writeMintRequest = writeMintRequest;
