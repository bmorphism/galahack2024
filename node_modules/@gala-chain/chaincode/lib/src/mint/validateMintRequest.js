"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateMintRequest = void 0;
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const allowances_1 = require("../allowances");
const utils_1 = require("../utils");
async function validateMintRequest(ctx, dto, tokenClass, authorizedOnBehalf) {
    var _a, _b, _c;
    const callingUser = ctx.callingUser;
    const owner = (_a = dto.owner) !== null && _a !== void 0 ? _a : callingUser;
    const tokenClassKey = dto.tokenClass;
    const quantity = dto.quantity;
    const callingOnBehalf = (_b = authorizedOnBehalf === null || authorizedOnBehalf === void 0 ? void 0 : authorizedOnBehalf.callingOnBehalf) !== null && _b !== void 0 ? _b : callingUser;
    const decimalPlaces = (_c = quantity.decimalPlaces()) !== null && _c !== void 0 ? _c : 0;
    if (decimalPlaces > tokenClass.decimals) {
        throw new Error(`Quantity: ${quantity} has more than ${tokenClass.decimals} decimal places.`);
    }
    // dto is valid, do chain code specific validation
    let results = [];
    if (dto.allowanceKey) {
        const applicableAllowanceKey = dto.allowanceKey;
        const allowance = await (0, utils_1.getObjectByKey)(ctx, api_1.TokenAllowance, api_1.ChainObject.getCompositeKeyFromParts(api_1.TokenAllowance.INDEX_KEY, [
            applicableAllowanceKey.grantedTo,
            applicableAllowanceKey.collection,
            applicableAllowanceKey.category,
            applicableAllowanceKey.type,
            applicableAllowanceKey.additionalKey,
            applicableAllowanceKey.instance.toString(),
            applicableAllowanceKey.allowanceType.toString(),
            applicableAllowanceKey.grantedBy,
            applicableAllowanceKey.created.toString()
        ]));
        results = [allowance];
    }
    else {
        const queryParams = [
            callingOnBehalf, // grantedTo
            tokenClassKey.collection,
            tokenClassKey.category,
            tokenClassKey.type,
            tokenClassKey.additionalKey,
            api_1.TokenInstance.FUNGIBLE_TOKEN_INSTANCE.toString(),
            api_1.AllowanceType.Mint.toString()
        ];
        results = await (0, utils_1.getObjectsByPartialCompositeKey)(ctx, api_1.TokenAllowance.INDEX_KEY, queryParams, api_1.TokenAllowance);
        results.sort((a, b) => (a.created < b.created ? -1 : 1));
    }
    const applicableAllowances = results;
    const dtoInstanceKey = api_1.ChainCallDTO.deserialize(api_1.TokenInstanceKey, {
        ...tokenClassKey,
        instance: api_1.TokenInstance.FUNGIBLE_TOKEN_INSTANCE
    });
    // Check allowances
    const allowanceType = api_1.AllowanceType.Mint;
    const totalAllowance = await (0, allowances_1.checkAllowances)(ctx, applicableAllowances, dtoInstanceKey, allowanceType, callingOnBehalf);
    const actionDescription = `${api_1.AllowanceType[allowanceType]} ${quantity.toString()} ` +
        `token ${dtoInstanceKey.toStringKey()} to ${owner}`;
    if (totalAllowance.isLessThan(quantity)) {
        throw new Error(`${callingUser} does not have sufficient allowances ${totalAllowance.toString()} to ${actionDescription}`);
    }
    return applicableAllowances;
}
exports.validateMintRequest = validateMintRequest;
