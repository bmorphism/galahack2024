"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.objectExists = exports.getObjectsByKeys = exports.getObjectHistory = exports.getPlainObjectByKey = exports.getObjectByKey = exports.getObjectsByPartialCompositeKeyWithPagination = exports.getObjectsByPartialCompositeKey = exports.deleteChainObject = exports.putRangedChainObject = exports.putChainObject = exports.InvalidResultsError = exports.NoObjectIdsError = exports.ObjectNotFoundError = void 0;
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
// Fabric default value, we don't want to change it
// see https://hyperledger-fabric.readthedocs.io/en/latest/performance.html#total-query-limit
const TOTAL_RESULTS_LIMIT = 100 * 1000;
class ObjectNotFoundError extends api_1.NotFoundError {
    constructor(objectId) {
        super(`No object with id ${objectId} exists`, { objectId });
    }
}
exports.ObjectNotFoundError = ObjectNotFoundError;
class NoObjectIdsError extends api_1.ValidationFailedError {
    constructor() {
        super("objectIds parameter cannot be empty");
    }
}
exports.NoObjectIdsError = NoObjectIdsError;
class InvalidResultsError extends api_1.DefaultError {
    constructor(messages) {
        super("Cannot get all results", { messages });
    }
}
exports.InvalidResultsError = InvalidResultsError;
async function putChainObject(ctx, data) {
    await data.validateOrReject();
    return ctx.stub.putState(data.getCompositeKey(), Buffer.from(data.serialize()));
}
exports.putChainObject = putChainObject;
async function putRangedChainObject(ctx, data) {
    await data.validateOrReject();
    return ctx.stub.putState(data.getRangedKey(), Buffer.from(data.serialize()));
}
exports.putRangedChainObject = putRangedChainObject;
async function deleteChainObject(ctx, data) {
    return ctx.stub.deleteState(data.getCompositeKey());
}
exports.deleteChainObject = deleteChainObject;
async function getObjectsByPartialCompositeKey(ctx, objectType, attributes, constructor) {
    const iterator = ctx.stub.getCachedStateByPartialCompositeKey(objectType, attributes);
    const allResults = [];
    for await (const res of iterator) {
        const stringResult = Buffer.from(res.value).toString("utf8");
        allResults.push(api_1.ChainObject.deserialize(constructor, stringResult));
    }
    if (allResults.length >= TOTAL_RESULTS_LIMIT) {
        const message = `Reached total results limit (${TOTAL_RESULTS_LIMIT}). ` +
            `It means your results would be probably incomplete. ` +
            `Please narrow your query or use pagination.`;
        throw new api_1.ForbiddenError(message, { objectType, attributes });
    }
    // iterator will be automatically closed on exit from the loop
    // either by reaching the end, or a break or throw terminated the loop
    return allResults;
}
exports.getObjectsByPartialCompositeKey = getObjectsByPartialCompositeKey;
async function getObjectsByPartialCompositeKeyWithPagination(ctx, objectType, attributes, constructor, bookmark, limit = TOTAL_RESULTS_LIMIT) {
    // Uses default fabric call. No need for cache support, since Fabric disallows
    // this call in submit queries.
    const response = ctx.stub.getStateByPartialCompositeKeyWithPagination(objectType, attributes, limit, bookmark);
    const results = [];
    for await (const res of response) {
        const stringResult = Buffer.from(res.value).toString("utf8");
        results.push(api_1.ChainObject.deserialize(constructor, stringResult));
    }
    const metadata = (await response).metadata;
    return { results, metadata };
}
exports.getObjectsByPartialCompositeKeyWithPagination = getObjectsByPartialCompositeKeyWithPagination;
async function getObjectByKey(ctx, constructor, objectId) {
    const objectBuffer = await ctx.stub.getCachedState(objectId);
    if (!objectBuffer || objectBuffer.length === 0) {
        throw new ObjectNotFoundError(objectId);
    }
    return api_1.ChainObject.deserialize(constructor, objectBuffer.toString());
}
exports.getObjectByKey = getObjectByKey;
async function getPlainObjectByKey(ctx, objectId) {
    const objectBuffer = await ctx.stub.getCachedState(objectId);
    if (!objectBuffer || objectBuffer.length === 0) {
        throw new ObjectNotFoundError(objectId);
    }
    return JSON.parse(objectBuffer.toString());
}
exports.getPlainObjectByKey = getPlainObjectByKey;
async function getObjectHistory(ctx, objectId) {
    const iterator = await ctx.stub.getHistoryForKey(objectId);
    const history = [];
    let res = await iterator.next();
    while (!res.done) {
        if (res.value) {
            history.push(res.value);
        }
        res = await iterator.next();
    }
    await iterator.close();
    return { history };
}
exports.getObjectHistory = getObjectHistory;
/**
 * Gets objects by keys and returns them in the same order as in `projectIds` parameter.
 * If getting at least one object fails, throws an exception.
 */
async function getObjectsByKeys(ctx, constructor, objectIds) {
    if (objectIds.length < 1) {
        throw new NoObjectIdsError();
    }
    // Start all async operations
    const operations = objectIds.map((id) => getObjectByKey(ctx, constructor, id));
    const results = await operations.reduce(async (currentResults, operation, i) => {
        const { successes, failures } = await currentResults;
        try {
            return { successes: [...successes, await operation], failures: failures };
        }
        catch (e) {
            return {
                successes: successes,
                failures: [...failures, { id: objectIds[i], message: e.message }]
            };
        }
    }, Promise.resolve({ successes: [], failures: [] }));
    if (results.failures.length) {
        const messages = results.failures.map(({ id, message }) => `${id}: ${message}`);
        throw new InvalidResultsError(messages);
    }
    else {
        return results.successes;
    }
}
exports.getObjectsByKeys = getObjectsByKeys;
// objectExists returns true when asset with given ID exists in world state.
// Only use this if we don't need the data from the chain
async function objectExists(ctx, id) {
    const assetJSON = await ctx.stub.getCachedState(id);
    return assetJSON && assetJSON.length > 0;
}
exports.objectExists = objectExists;
