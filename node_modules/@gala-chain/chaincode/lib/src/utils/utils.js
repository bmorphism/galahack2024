"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.txUnixTimeToDateIndexKeys = exports.takeUntilUndefined = exports.generateInverseTimeKey = exports.inverseTime = exports.inverseEpoch = exports.lookbackTimeOffset = exports.lookbackTxCount = exports.inverseKeyLength = exports.inversionHeight = exports.blockTimeout = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@gala-chain/api");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
// Block timeout can change on peers, using it makes this brittle. However,
// getting epoch or block number via fabric-ledger, system chaincode call,
// and epoch from proposal header all fail to work as of 2022-12-08.
let blockTimeoutConfig;
if (process.env.HLF_BLOCK_TIMEOUT) {
    const envTimeout = parseInt(process.env.HLF_BLOCK_TIMEOUT);
    if (isFinite(envTimeout)) {
        blockTimeoutConfig = envTimeout;
    }
}
exports.blockTimeout = blockTimeoutConfig !== null && blockTimeoutConfig !== void 0 ? blockTimeoutConfig : 2000;
// roughly 4.5 billion ms into the future from the unix epoch
// 1000ms * 60s * 60m * 24h * 365d * 45000000000y
// "0141912000000000000000"
exports.inversionHeight = 1.41912e20;
exports.inverseKeyLength = 22;
exports.lookbackTxCount = 200;
exports.lookbackTimeOffset = exports.blockTimeout * 2;
function inverseEpoch(ctx, offset) {
    // assuming epoch is a growing integer tied to block height
    // create an inverse that can be used to create a lexigraphic key or
    // create an offset key for GetStateByRange exclusive of current height
    const decodedSP = ctx.stub.getSignedProposal();
    const epoch = decodedSP.proposal.header.channelHeader.epoch;
    offset = offset ? offset : 0;
    const height = new bignumber_js_1.default(epoch).minus(new bignumber_js_1.default(offset));
    const heightMax = exports.inversionHeight;
    const len = exports.inverseKeyLength;
    const inverse = new bignumber_js_1.default(heightMax).minus(height).toString().padStart(len, "0");
    return inverse;
}
exports.inverseEpoch = inverseEpoch;
function inverseTime(ctx, offset) {
    // create an inverse that can be used to create a lexigraphic key or
    // create an offset key for GetStateByRange exclusive of current height
    const txtime = ctx.txUnixTime;
    offset = offset ? offset : 0;
    const height = new bignumber_js_1.default(txtime).minus(new bignumber_js_1.default(offset)).toNumber();
    return generateInverseTimeKey(height);
}
exports.inverseTime = inverseTime;
function generateInverseTimeKey(height) {
    const heightMax = exports.inversionHeight;
    const len = exports.inverseKeyLength;
    const inverse = new bignumber_js_1.default(heightMax).minus(height).toString().padStart(len, "0");
    return inverse;
}
exports.generateInverseTimeKey = generateInverseTimeKey;
function takeUntilUndefinedRecursive(args, originalArray) {
    if (args.length === 0) {
        return [];
    }
    else if (args[0] === undefined) {
        // expect all remaining fields to be undefined
        const definedField = args.find((a) => a !== undefined);
        if (!definedField) {
            return [];
        }
        else {
            const arrStr = `[${originalArray.join(",")}]`;
            const message = `Expected all remaining fields to be undefined, but found: ${definedField} in [${arrStr}]`;
            throw new api_1.ValidationFailedError(message);
        }
    }
    else {
        return [args[0], ...takeUntilUndefinedRecursive(args.slice(1), originalArray)];
    }
}
function takeUntilUndefined(...args) {
    return takeUntilUndefinedRecursive(args, args);
}
exports.takeUntilUndefined = takeUntilUndefined;
function txUnixTimeToDateIndexKeys(txUnixTime) {
    const txDate = new Date(txUnixTime);
    const year = `${txDate.getUTCFullYear()}`;
    // JavaScript's Date.getUTCMonth returns the month as a Zero-indexed value;
    // so we add one below to get a human-readable month number.
    const month = `${txDate.getUTCMonth() + 1}`.padStart(2, "0");
    const day = `${txDate.getUTCDate()}`.padStart(2, "0");
    const hours = `${txDate.getUTCHours()}`.padStart(2, "0");
    const minutes = `${txDate.getUTCMinutes()}`.padStart(2, "0");
    const seconds = `${txDate.getUTCSeconds()}`.padStart(2, "0");
    const milliseconds = `${txDate.getUTCMilliseconds()}`.padStart(4, "0");
    return {
        year,
        month,
        day,
        hours,
        minutes,
        seconds,
        milliseconds
    };
}
exports.txUnixTimeToDateIndexKeys = txUnixTimeToDateIndexKeys;
