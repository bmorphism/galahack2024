"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.overwriteApiConfig = exports.getPrivateKey = exports.generateKeys = exports.deployChaincode = exports.getDeploymentResponse = exports.readDockerfile = exports.readPackageJsonVersion = exports.readConfigFile = exports.writeConfigFile = exports.DEFAULT_DEV_PRIVATE_KEY_NAME = exports.DEFAULT_ADMIN_PRIVATE_KEY_NAME = exports.DEFAULT_PRIVATE_KEYS_DIR = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const core_1 = require("@oclif/core");
const api_1 = require("@gala-chain/api");
const secp = tslib_1.__importStar(require("@noble/secp256k1"));
const axios_1 = tslib_1.__importDefault(require("axios"));
const fs_1 = tslib_1.__importStar(require("fs"));
const nanoid_1 = require("nanoid");
const promises_1 = require("node:fs/promises");
const path_1 = tslib_1.__importDefault(require("path"));
const process_1 = tslib_1.__importDefault(require("process"));
const consts_1 = require("./consts");
const exec_sync_1 = require("./exec-sync");
const utils_1 = require("./utils");
const ConfigFileName = ".galachainrc.json";
const PackageJsonFileName = "package.json";
exports.DEFAULT_PRIVATE_KEYS_DIR = "keys";
exports.DEFAULT_ADMIN_PRIVATE_KEY_NAME = "gc-admin-key";
exports.DEFAULT_DEV_PRIVATE_KEY_NAME = "gc-dev-key";
async function writeConfigFile(config) {
    await fs_1.promises.writeFile(ConfigFileName, JSON.stringify(config, null, 2));
}
exports.writeConfigFile = writeConfigFile;
async function readConfigFile() {
    try {
        return JSON.parse(await fs_1.promises.readFile(ConfigFileName, "utf8"));
    }
    catch (error) {
        throw new Error(`Can not read chain config file ${ConfigFileName}`);
    }
}
exports.readConfigFile = readConfigFile;
async function readPackageJsonVersion() {
    try {
        const packageJson = JSON.parse(await fs_1.promises.readFile(PackageJsonFileName, "utf8"));
        return packageJson.version;
    }
    catch (error) {
        throw new Error(`Can not find package.json file.`);
    }
}
exports.readPackageJsonVersion = readPackageJsonVersion;
async function readDockerfile() {
    try {
        return await fs_1.promises.readFile("Dockerfile", "utf8");
    }
    catch (error) {
        throw new Error(`Can not find Dockerfile.`);
    }
}
exports.readDockerfile = readDockerfile;
async function getDeploymentResponse(params) {
    const getChaincodeDeploymentDto = {
        operationId: (0, nanoid_1.nanoid)()
    };
    const signature = await generateSignature(getChaincodeDeploymentDto, params.privateKey);
    const ServicePortalURL = params.isTestnet
        ? consts_1.ServicePortal.GET_TEST_DEPLOYMENT_URL
        : consts_1.ServicePortal.GET_DEPLOYMENT_URL;
    const response = await axios_1.default.get(ServicePortalURL, {
        headers: {
            [consts_1.ServicePortal.AUTH_X_GC_KEY]: signature
        },
        params: getChaincodeDeploymentDto
    });
    if (response.status !== 200) {
        throw new Error(`Service Portal respond with status ${response.status}`);
    }
    return response.data;
}
exports.getDeploymentResponse = getDeploymentResponse;
function getContractNames(imageTag) {
    const command = `docker run --rm ${imageTag} lib/src/cli.js get-contract-names | tail -n 1`;
    let response = "<failed>";
    try {
        response = (0, exec_sync_1.execSync)(command);
        const json = JSON.parse(response);
        if (!Array.isArray(json)) {
            throw new Error("Is not array");
        }
        json.forEach((n) => {
            if (typeof n?.contractName !== "string") {
                throw new Error("Not all elements contain 'contractName' string");
            }
        });
        return json.map(({ contractName }) => ({ contractName }));
    }
    catch (e) {
        throw new Error(`Invalid contract names config (${e?.message}): ${response}`);
    }
}
async function deployChaincode(params) {
    const chainCodeDto = {
        operationId: (0, nanoid_1.nanoid)(),
        imageTag: params.imageTag,
        contracts: getContractNames(params.imageTag)
    };
    const signature = await generateSignature(chainCodeDto, params.privateKey);
    const ServicePortalURL = params.isTestnet ? consts_1.ServicePortal.DEPLOY_TEST_URL : consts_1.ServicePortal.DEPLOY_URL;
    const response = await axios_1.default.post(ServicePortalURL, chainCodeDto, {
        headers: {
            [consts_1.ServicePortal.AUTH_X_GC_KEY]: signature
        }
    });
    if (response.status !== 201) {
        throw new Error(`Service Portal respond with status ${response.status}`);
    }
    return response.data;
}
exports.deployChaincode = deployChaincode;
async function generateKeys(keysPath) {
    const adminPrivateKey = secp.utils.bytesToHex(secp.utils.randomPrivateKey());
    const adminPublicKey = secp.utils.bytesToHex(secp.getPublicKey(adminPrivateKey));
    const devPrivateKey = secp.utils.bytesToHex(secp.utils.randomPrivateKey());
    const devPublicKey = secp.utils.bytesToHex(secp.getPublicKey(devPrivateKey));
    fs_1.default.mkdir(`${keysPath}`, (err) => {
        if (err)
            console.error(`Could not create a directory ${keysPath}. Error: ${err}`);
    });
    await (0, promises_1.writeFile)(`${keysPath}/${exports.DEFAULT_ADMIN_PRIVATE_KEY_NAME}.pub`, adminPublicKey);
    await (0, promises_1.writeFile)(`${keysPath}/${exports.DEFAULT_ADMIN_PRIVATE_KEY_NAME}`, adminPrivateKey.toString());
    await (0, promises_1.writeFile)(`${keysPath}/${exports.DEFAULT_DEV_PRIVATE_KEY_NAME}.pub`, devPublicKey);
    await (0, promises_1.writeFile)(`${keysPath}/${exports.DEFAULT_DEV_PRIVATE_KEY_NAME}`, devPrivateKey.toString());
}
exports.generateKeys = generateKeys;
async function getPrivateKey(keysFromArg) {
    return (keysFromArg || process_1.default.env.DEV_PRIVATE_KEY || getPrivateKeyFromFile() || (await getPrivateKeyPrompt()));
}
exports.getPrivateKey = getPrivateKey;
async function overwriteApiConfig(contracts, channel, chaincodeName) {
    const contractsJson = JSON.parse(contracts);
    let contractJson = "";
    contractsJson.forEach((contract) => {
        // It converts CamelCase to kebab-case
        const pathFragment = contract.contractName
            .replace(/([A-Z])/g, "-$1")
            .toLowerCase()
            .replace(/^-/, "");
        contractJson =
            contractJson +
                `{ 
          "pathFragment": "${pathFragment}", 
          "chaincodeName": "${chaincodeName}", 
          "contractName": "${contract.contractName}" 
        },`;
    });
    // remove the last comma
    contractJson = contractJson.slice(0, -1);
    // write a new api-config.json file and overwrite the old one
    const apiConfigPath = path_1.default.resolve(".", "api-config.json");
    const apiConfigJson = `{
        "channels": [
          {
            "pathFragment": "product",
            "channelName": "${channel}",
            "asLocalHost": true,
            "contracts": [${contractJson}]
          }
        ]
      }`;
    fs_1.default.writeFileSync(apiConfigPath, JSON.stringify(JSON.parse(apiConfigJson), null, 2));
}
exports.overwriteApiConfig = overwriteApiConfig;
function getPrivateKeyFromFile() {
    try {
        return fs_1.default.readFileSync(`${process_1.default.cwd()}/${exports.DEFAULT_PRIVATE_KEYS_DIR}/${exports.DEFAULT_DEV_PRIVATE_KEY_NAME}`, "utf8");
    }
    catch (e) {
        console.error(`Error reading file: ${e}`);
    }
}
async function getPrivateKeyPrompt() {
    console.log("Private key not found. It should be provided as an argument, as an environment variable DEV_PRIVATE_KEY or as a file.");
    return await core_1.ux.prompt("Type the private key or the path to", { type: "mask" });
}
async function generateSignature(obj, privateKey) {
    const privateKeyValue = await (0, utils_1.parseStringOrFileKey)(privateKey);
    const keyBuffer = api_1.signatures.normalizePrivateKey(privateKeyValue);
    return api_1.signatures.getSignature(obj, keyBuffer);
}
