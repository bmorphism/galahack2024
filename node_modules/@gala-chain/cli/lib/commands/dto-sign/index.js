"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const core_1 = require("@oclif/core");
const api_1 = require("@gala-chain/api");
const promises_1 = require("fs/promises");
const base_command_1 = tslib_1.__importDefault(require("../../base-command"));
const utils_1 = require("../../utils");
class DtoSign extends base_command_1.default {
    async run() {
        const { flags, args } = await this.parse(DtoSign);
        const privateKey = (await (0, utils_1.parseStringOrFileKey)(args.key));
        const keyBuffer = api_1.signatures.normalizePrivateKey(privateKey);
        const dto = (await (0, utils_1.parseJsonFromStringOrFile)(args.data));
        dto.signature = flags.derSignature
            ? api_1.signatures.getDERSignature(dto, keyBuffer)
            : api_1.signatures.getSignature(dto, keyBuffer);
        dto.signature = Buffer.from(dto.signature, "hex").toString("base64");
        const output = flags.onlySignature ? dto.signature : (0, api_1.serialize)(dto);
        if (flags.outputFile) {
            await (0, promises_1.writeFile)(flags.outputFile, output, "utf-8").catch((e) => {
                this.log(`Failed to writeFile to ${flags.outputFile}. ${e}`);
                this.log(output);
                return;
            });
        }
        else {
            this.log(output);
        }
    }
}
DtoSign.aliases = ["dto:sign"];
DtoSign.description = "DTO (Data Transfer Object) signing.";
DtoSign.examples = [
    `galachain dto:sign -o=output/path ./testkey '{
      "tokenClass": {
        "collection": "CLITest",
        "category": "Currency",
      }
    }'`,
    "galachain dto:sign ./testkey dto.json -o=output/path",
    "galachain dto:sign ./testkey dto.json -d",
    "galachain dto:sign 04ea7e8e14f2a0 dto.json -s -o=output/path -d"
];
DtoSign.flags = {
    outputFile: core_1.Flags.string({
        char: "o",
        description: "(optional) File path to an output directory where the signed DTO JSON file will be written. " +
            "If not provided, signed DTO will be printed to stdout."
    }),
    derSignature: core_1.Flags.boolean({
        char: "d",
        default: false,
        description: "(optional) If provided, the signature will be used as DER format."
    }),
    onlySignature: core_1.Flags.boolean({
        char: "s",
        default: false,
        description: "(optional) If provided, only the signature will be printed to stdout or written to a file."
    })
};
DtoSign.args = {
    key: core_1.Args.string({
        char: "k",
        description: "Private key string or path to the private key file.",
        required: true
    }),
    data: core_1.Args.string({
        char: "D",
        description: "Data representing an unsigned DTO object you wish to sign. Provide a JSON string " +
            "or a path to a valid JSON file.",
        required: true
    })
};
exports.default = DtoSign;
