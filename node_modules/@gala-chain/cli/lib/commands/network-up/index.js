"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updatedFabloConfig = exports.createConfigtxProfiles = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const core_1 = require("@oclif/core");
const fablo_1 = require("fablo");
const fs = tslib_1.__importStar(require("fs"));
const fs_1 = require("fs");
const path_1 = tslib_1.__importDefault(require("path"));
const base_command_1 = tslib_1.__importDefault(require("../../base-command"));
const connection_profile_1 = require("../../connection-profile");
const consts_1 = require("../../consts");
const exec_sync_1 = require("../../exec-sync");
const galachain_utils_1 = require("../../galachain-utils");
const defaultChaincodeDir = ".";
class NetworkUp extends base_command_1.default {
    async run() {
        const { flags } = await this.parse(NetworkUp);
        customValidation(flags);
        if (flags.contracts) {
            // This feature supports only a single channel
            console.log("Overwriting api-config.json with contracts: " + flags.contracts);
            (0, galachain_utils_1.overwriteApiConfig)(flags.contracts, flags.channel[0], flags.chaincodeName[0]);
        }
        const fabloRoot = path_1.default.resolve(flags.fabloRoot);
        const localhostName = process.env.LOCALHOST_NAME ?? "localhost";
        console.log("Network root directory:", fabloRoot);
        await copyNetworkScriptsTo(fabloRoot);
        const singleArgs = reduce(flags).map((a) => ({
            ...a,
            chaincodeDir: a.chaincodeDir ?? defaultChaincodeDir
        }));
        const fabloConfig = flags.watch ? "fablo-config-dev-mode.json" : "fablo-config-default.json";
        await fablo_1.Fablo.directory(fabloRoot)
            .then(() => saveConnectionProfiles(fabloRoot, flags.watch, flags.channel ?? [], localhostName))
            .config(fabloConfig, (cfg) => updatedFabloConfig(cfg, fabloRoot, singleArgs))
            .then(() => updateConfigTxWithChannelProfile(fabloRoot, singleArgs))
            .then(() => copyEnvFile(fabloRoot, flags.envConfig, singleArgs.map((a) => a.chaincodeDir)))
            .execute("up");
        startBrowserApi(fabloRoot);
        if (flags.watch) {
            startChaincodeInWatchMode(fabloRoot, singleArgs);
        }
    }
}
NetworkUp.aliases = ["network:up"];
NetworkUp.description = "Start the chaincode in dev-mode and browser-api.";
NetworkUp.examples = [
    "galachain network:up -C=product-channel -t=curator -n=basic-product -d=./ --envConfig=./.dev-env --watch",
    "galachain network:up -C=product-channel -t=curator -n=basic-product -d=./ --envConfig=./.dev-env"
];
NetworkUp.flags = {
    channel: core_1.Flags.string({
        char: "C",
        description: "Channel name.",
        required: true,
        multiple: true
    }),
    channelType: core_1.Flags.string({
        char: "t",
        description: 'Channel type. Can be "curator" or "partner". It means whether this is a chaincode managed by CuratorOrg or PartnerOrg.',
        required: true,
        options: ["curator", "partner"],
        multiple: true
    }),
    chaincodeName: core_1.Flags.string({
        char: "n",
        description: "Chaincode name.",
        required: true,
        multiple: true
    }),
    chaincodeDir: core_1.Flags.string({
        char: "d",
        description: "Root directory of chaincode source, relative to fabloRoot. " +
            `By default '${defaultChaincodeDir}' is used.`,
        default: [defaultChaincodeDir],
        multiple: true
    }),
    fabloRoot: core_1.Flags.string({
        char: "r",
        description: "Root directory of target network. " +
            "Should not be the same as chaincodeDir and should not be a child of chaincodeDir. " +
            `By default '${consts_1.defaultFabloRoot}' is used.`,
        default: consts_1.defaultFabloRoot
    }),
    envConfig: core_1.Flags.string({
        char: "e",
        description: "Path to .env file to be used for chaincodes."
    }),
    watch: core_1.Flags.boolean({
        char: "w",
        description: "Enable watch mode (live chaincode reload)."
    }),
    contracts: core_1.Flags.string({
        char: "o",
        description: "Contract names in a JSON format."
    })
};
exports.default = NetworkUp;
function startBrowserApi(fabloRoot) {
    const commands = [
        `cd "${fabloRoot}/browser-api"`,
        "./browser-api-compose.sh up",
        "./browser-api-compose.sh success-message"
    ];
    (0, exec_sync_1.execSyncStdio)(commands.join(" && "));
}
function startChaincodeInWatchMode(fabloRoot, args) {
    const chaincodeName = args[0].chaincodeName;
    const commands = [`cd "${fabloRoot}"`, `./chaincode-dev-start.sh "watch" "${chaincodeName}"`];
    (0, exec_sync_1.execSyncStdio)(commands.join(" && "));
}
function copyEnvFile(fabloRoot, envConfigPath, chaincodeDirs) {
    if (!envConfigPath) {
        return;
    }
    const envConfig = (0, fs_1.readFileSync)(path_1.default.resolve(fabloRoot, "..", envConfigPath)).toString();
    chaincodeDirs.forEach((dir) => {
        const chaincodeEnvPath = path_1.default.resolve("./", dir, ".env");
        (0, fs_1.writeFileSync)(chaincodeEnvPath, envConfig);
    });
}
function updateConfigTxWithChannelProfile(fabloRoot, args) {
    const update = createConfigtxProfiles(args);
    const configtxFilePath = path_1.default.resolve(fabloRoot, "configtx-policies.yml");
    fs.appendFileSync(configtxFilePath, update);
}
function createConfigtxProfiles(args) {
    const profiles = args.map(({ channel, channelType }) => {
        const configtxProfileName = channel.replace(/(^\w|-\w)/g, (t) => t.replace(/-/, "").toUpperCase());
        const configtxProfileDefaults = channelType === "curator" ? "CuratorChannelDefaults" : "PartnerChannelDefaults";
        return `  ${configtxProfileName}:\n    <<: *${configtxProfileDefaults}`;
    });
    return `\n${profiles.join("\n")}`;
}
exports.createConfigtxProfiles = createConfigtxProfiles;
function updatedFabloConfig(initialCfg, fabloRoot, args) {
    return args.reduce((cfg, arg) => updatedFabloConfigWithEntry(cfg, fabloRoot, arg), initialCfg);
}
exports.updatedFabloConfig = updatedFabloConfig;
function updatedFabloConfigWithEntry(initialCfg, fabloRoot, arg) {
    const updated = JSON.parse(JSON.stringify(initialCfg)); // deep copy
    const channelExists = updated.channels.find((c) => c.name === arg.channel);
    if (!channelExists) {
        const newChannel = {
            name: arg.channel,
            ordererGroup: "group1",
            orgs: [
                {
                    name: "CuratorOrg",
                    peers: ["peer0"]
                },
                {
                    name: "PartnerOrg1",
                    peers: ["peer0"]
                }
            ]
        };
        updated.channels.push(newChannel);
    }
    const absoluteChaincodeDir = path_1.default.resolve(arg.chaincodeDir ?? "./");
    const relativeChaincodeDir = path_1.default.relative(fabloRoot, absoluteChaincodeDir);
    updated.chaincodes.push({
        name: arg.chaincodeName,
        version: "0.0.1",
        lang: "node",
        channel: arg.channel,
        directory: relativeChaincodeDir
    });
    return updated;
}
function customValidation(flags) {
    const { channel, channelType, chaincodeName, chaincodeDir } = flags;
    /*
      The same number of parameters for chaincode, channelTyle, chaincode and chaincodeDir is required
    */
    if (channel.length !== channelType.length ||
        channel.length !== chaincodeName.length ||
        channel.length !== chaincodeDir.length) {
        throw new Error(`Error: Specified ${channel.length} channel names, ${channelType.length} channel types, ${chaincodeName.length} chaincodes and ${chaincodeDir.length} chaincode directories. All parameters must have the same number of values.`);
    }
    /*
      Channel types need to be consistend
    */
    channel.reduce((types, ch, i) => {
        if (!types[ch]) {
            types[ch] = channelType[i];
            return types;
        }
        else if (types[ch] !== channelType[i]) {
            throw new Error(`Error: Channel ${ch} is provided both as ${types[ch]} and ${channelType[i]}. It should be consistent.`);
        }
        else {
            return types;
        }
    }, {});
    /*
      (channel, chaincodeName) pairs should be unique
    */
    channel
        .map((ch, i) => `(${ch}, ${chaincodeName[i]})`)
        .forEach((pair, i, arr) => {
        if (arr.filter((p) => p === pair).length > 1) {
            throw new Error(`Error: Found non-unique channel-chaincode pair: ${pair}`);
        }
    });
    /*
      Watch mode
    */
    if (flags.watch) {
        if (chaincodeName.length !== 1) {
            throw new Error("Error: Watch mode suports only a network with a single chaincode.");
        }
    }
}
function reduce(args) {
    return args.chaincodeName.map((chaincodeName, i) => ({
        chaincodeName,
        chaincodeDir: args.chaincodeDir?.[i],
        channel: args.channel[i],
        channelType: args.channelType[i]
    }));
}
function copyNetworkScriptsTo(targetPath) {
    const sourceScriptsDir = path_1.default.resolve(require.resolve("."), "../../../network");
    (0, exec_sync_1.execSync)(`mkdir -p "${targetPath}" && cd "${targetPath}" && cp -R "${sourceScriptsDir}"/* ./ && ls -lh`);
}
function saveConnectionProfiles(fabloRoot, isWatchMode, channelNames, localhostName) {
    // e2e tests
    const cryptoConfigRoot = path_1.default.resolve(fabloRoot, "fablo-target/fabric-config/crypto-config");
    const cpps = (0, connection_profile_1.getCPPs)(cryptoConfigRoot, channelNames, localhostName, !isWatchMode, true, !isWatchMode);
    const cppDir = path_1.default.resolve(fabloRoot, "connection-profiles");
    (0, exec_sync_1.execSync)(`mkdir -p "${cppDir}"`);
    const cppPath = (org) => path_1.default.resolve(cppDir, `cpp-${org}.json`);
    (0, fs_1.writeFileSync)(cppPath("curator"), JSON.stringify(cpps.curator, undefined, 2));
    (0, fs_1.writeFileSync)(cppPath("partner"), JSON.stringify(cpps.partner, undefined, 2));
    (0, fs_1.writeFileSync)(cppPath("users"), JSON.stringify(cpps.users, undefined, 2));
    // browser-api
    const cppsBrowser = (0, connection_profile_1.getCPPsBrowserApi)(cryptoConfigRoot, channelNames, localhostName, !isWatchMode, false, !isWatchMode);
    const cppDirBrowser = path_1.default.resolve(fabloRoot, "connection-profiles-browser");
    (0, exec_sync_1.execSync)(`mkdir -p "${cppDirBrowser}"`);
    // Browser-api needs the generated connection profile when running in watch mode and the harded coded one when running in non-watch mode
    if (isWatchMode) {
        const cppPathBrowser = (org) => path_1.default.resolve(cppDirBrowser, `cpp-${org}.json`);
        (0, fs_1.writeFileSync)(cppPathBrowser("curator"), JSON.stringify(cppsBrowser.curator, undefined, 2));
    }
    else {
        const sourceCppDirBrowser = path_1.default.resolve(".", `${consts_1.defaultFabloRoot}/browser-api/connection-profiles`);
        (0, exec_sync_1.execSync)(`cp "${sourceCppDirBrowser}/cpp-curator.json" "${cppDirBrowser}/"`);
    }
}
