"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const core_1 = require("@oclif/core");
const deploy_1 = tslib_1.__importDefault(require("../../../src/commands/deploy"));
const galachain_utils_1 = require("../../../src/galachain-utils");
jest.mock("../../../src/galachain-utils");
const consts = {
    developerPrivateKey: "bf2168e0e2238b9d879847987f556a093040a2cab07983a20919ac33103d0d00"
};
describe("Deploy Command", () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });
    it("should deploy an image", async () => {
        // Given
        const result = [];
        jest.spyOn(process.stdout, "write").mockImplementation((v) => {
            result.push(v);
            return true;
        });
        jest.spyOn(console, "log").mockImplementation((v) => {
            result.push(v);
            return true;
        });
        jest.spyOn(core_1.ux, "prompt").mockResolvedValueOnce("Y");
        jest.mocked(galachain_utils_1.deployChaincode).mockResolvedValue({
            status: "CC_DEPLOY_SCHEDULED",
            chaincode: "chaincode-name",
            channel: "channel-name"
        });
        // When
        await deploy_1.default.run(["imageName:version", consts.developerPrivateKey]);
        // Then
        expect(result.join()).toContain("Deployment scheduled to sandbox. Status CC_DEPLOY_SCHEDULED for Chaincode chaincode-name and Channel channel-name.");
    });
    it("should cancel the deployment", async () => {
        // Given
        const result = [];
        jest.spyOn(process.stdout, "write").mockImplementation((v) => {
            result.push(v);
            return true;
        });
        jest.spyOn(console, "log").mockImplementation((v) => {
            result.push(v);
            return true;
        });
        jest.spyOn(core_1.ux, "prompt").mockResolvedValueOnce("n");
        jest.mocked(galachain_utils_1.deployChaincode).mockResolvedValue({
            status: "CC_DEPLOY_SCHEDULED",
            org: "org-name"
        });
        // When
        await deploy_1.default.run(["imageName:version", consts.developerPrivateKey]);
        // Then
        expect(result.join()).toContain("Deployment cancelled.");
    });
    it("should check imageTag", async () => {
        // Given
        const result = [];
        jest.spyOn(process.stdout, "write").mockImplementation((v) => {
            result.push(v);
            return true;
        });
        jest.spyOn(console, "log").mockImplementation((v) => {
            result.push(v);
            return true;
        });
        // When
        await deploy_1.default.run(["imageName", consts.developerPrivateKey]);
        // Then
        expect(result.join()).toContain("It should follow the pattern imageName:version.");
    });
    it("should log error when deployChaincode fail", async () => {
        // Given
        const result = [];
        jest.spyOn(process.stdout, "write").mockImplementation((v) => {
            result.push(v);
            return true;
        });
        jest.spyOn(console, "log").mockImplementation((v) => {
            result.push(v);
            return true;
        });
        jest.spyOn(core_1.ux, "prompt").mockResolvedValueOnce("y");
        jest.mocked(galachain_utils_1.deployChaincode).mockRejectedValue(new Error("Failed to deploy chaincode"));
        // When
        await deploy_1.default.run(["imageName:version", consts.developerPrivateKey]);
        // Then
        expect(result.join()).toContain("Failed to deploy chaincode");
    });
});
